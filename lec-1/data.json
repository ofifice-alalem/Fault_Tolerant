[
  {
    "slide_number": 2,
    "slide_title_ar": "ما هو \"الفشل\"؟",
    "slide_title_en": "What Is “Failure”?",
    "general_summary_ar": "هذه الشريحة أساسية جداً لأنها تضع حجر الأساس للمحاضرة كلها. هي تُعرّف المصطلحات الثلاثة الأهم: **الفشل (Failure)**، **الخطأ (Error)**، و**العطل (Fault)**. الأهم من ذلك، هي توضح العلاقة السببية (من يسبب ماذا) بين هذه المصطلحات الثلاثة.",
    "details_and_text": [
      {
        "text_en": "\"A system is said to “fail” when it cannot meet its promises.\"",
        "explanation_ar": "الفشل هو النتيجة النهائية التي يراها المستخدم. \"وعود\" النظام هي المهام التي صُمم ليقوم بها. مثال: \"وعد\" برنامج الآلة الحاسبة هو إعطاء ناتج جمع صحيح. إذا أعطاك ناتجاً خاطئاً، فهذا \"فشل\"."
      },
      {
        "text_en": "\"A failure is brought about by the existence of “errors” in the system.\"",
        "explanation_ar": "الفشل لا يحدث من فراغ. السبب المباشر له هو وجود \"خطأ\" واحد أو أكثر. \"الخطأ\" هو حالة (State) غير صحيحة داخل النظام. مثال (تابع): سبب الفشل (الناتج الخاطئ) هو \"خطأ\" في الذاكرة، كأن يتم تخزين قيمة 5 بدلاً من 2."
      },
      {
        "text_en": "\"The cause of an error is called a “fault”.\"",
        "explanation_ar": "هذا هو السبب الجذري. \"العطل\" هو العيب الأولي الذي تسبب في حدوث \"الخطأ\". مثال (تابع): سبب الخطأ (تخزين 5 بدلاً من 2) هو \"عطل\" في الكود أو في العتاد (Hardware). **التسلسل المنطقي هو: العطل (Fault) ⬅️ يسبب ⬅️ الخطأ (Error) ⬅️ والذي قد يؤدي إلى ⬅️ الفشل (Failure).**"
      }
    ],
    "questions_ar": {
      "a_current_slide": [
        "بناءً على هذه التعريفات، ما هو الفرق الرئيسي بين \"الخطأ\" (Error) و\"العطل\" (Fault)؟",
        "هل تعتقد أنه من الممكن أن يوجد \"عطل\" في النظام ولكنه لا يسبب \"فشل\"؟ (مثلاً، خطأ برمجي في جزء من الكود لا يتم استخدامه أبداً)."
      ],
      "b_previous_slides": [
        {
          "question_ar": "الشريحة الأولى أعطت عنوان \"Fault-Tolerant\" (تحمل الأخطاء). بناءً على تعريفات الشريحة الثانية، ماذا تتوقع أن يكون معنى \"تحمل الأخطاء\"؟",
          "hint_ar": "النظام يتصدى للعطل والخطأ لمنع الفشل."
        },
        {
          "question_ar": "بالنظر إلى صورة مكوك الفضاء، هل يمكنك تخمين مثال بسيط لـ \"عطل\" قد يؤدي إلى \"فشل\" كارثي في مهمة فضائية؟"
        }
      ]
    }
  },
  {
    "slide_number": 3,
    "slide_title_ar": "تحمل الأخطاء (Fault Tolerance)",
    "slide_title_en": "Fault Tolerance",
    "general_summary_ar": "هذه الشريحة تُعرّف المفهوم الرئيسي للمحاضرة. إنه قدرة النظام على الاستمرار في العمل بشكل صحيح حتى عند حدوث الأعطال، ويُصنَّف كـ **\"متطلب غير وظيفي\" (non-functional requirement)**، ويجب أن يحدث بأقل تدخل بشري ممكن.",
    "details_and_text": [
      {
        "text_en": "\"Ability of system to continue error-free operation in presence of unexpected fault.\"",
        "explanation_ar": "قدرة النظام على مواصلة التشغيل \"بدون أخطاء\" حتى لو واجه \"عطلاً\" (fault) غير متوقع. الهدف هو ألا يلاحظ المستخدم النهائي وجود مشكلة."
      },
      {
        "text_en": "\"Fault tolerance is a non-functional requirement that requires a system to continue to operate, even in the presence of faults.\"",
        "explanation_ar": "يُعد \"تحمل الأخطاء\" متطلباً غير وظيفي (Non-functional requirement) يصف جودة وكيفية عمل النظام، وليس وظيفته الأساسية."
      },
      {
        "text_en": "\"Fault tolerance should be achieved with minimal involvement of users or system administrators.\"",
        "explanation_ar": "يجب أن يتعافى النظام من الأعطال **تلقائياً** دون الحاجة إلى تدخل يدوي من المستخدمين أو مديري النظام."
      }
    ],
    "questions_en_ar": {
      "a_current_slide_qa": [
        {
          "type": "True/False",
          "question_en": "Fault tolerance means a system will never experience a \"fault\".",
          "answer_en": "False",
          "explanation_ar": "العبارة خاطئة. \"تحمل الأخطاء\" لا يمنع حدوث \"الأعطال\"، بل يعني أن النظام سيستمر في العمل *على الرغم من* حدوثها."
        },
        {
          "type": "Multiple Choice",
          "question_en": "According to the slide, fault tolerance is considered a:",
          "options": [
            "(a) Functional requirement",
            "(b) Non-functional requirement",
            "(c) System failure",
            "(d) Design fault"
          ],
          "answer_en": "(b) Non-functional requirement",
          "explanation_ar": "الإجابة الصحيحة هي (b) لأن الشريحة تصف \"تحمل الأخطاء\" صراحة بأنه \"متطلب غير وظيفي\"."
        },
        {
          "type": "True/False",
          "question_en": "A good fault-tolerant system relies on the system administrator to manually fix problems as they happen.",
          "answer_en": "False",
          "explanation_ar": "العبارة خاطئة. الشريحة تؤكد أن \"تحمل الأخطاء\" يجب أن يتم \"بأقل تدخل ممكن\" من مديري النظام أو المستخدمين. الهدف هو المعالجة التلقائية."
        }
      ],
      "b_previous_slides": [
        {
          "question_ar": "بناءً على تعريف \"تحمل الأخطاء\"، ما الذي يحاول النظام \"تحمله\"؟ هل يحاول منع \"العطل\" أم منع \"الفشل\"؟",
          "hint_ar": "النظام يحاول \"تحمل\" **العطل (Fault)** لمنع حدوث **الفشل (Failure)**."
        },
        {
          "question_ar": "بالنظر إلى صورة المكوكات الفضائية، لماذا تعتقد أن \"تحمل الأخطاء\" بأقل تدخل بشري هو أمر حيوي جداً في نظام مثل مكوك الفضاء؟"
        }
      ]
    }
  },
  {
    "slide_number": 4,
    "slide_title_ar": "المفاهيم الأساسية (Basic Concepts)",
    "slide_title_en": "Basic Concepts",
    "general_summary_ar": "توضح هذه الشريحة أن مفهوم \"تحمل الأخطاء\" يرتبط ارتباطًا وثيقًا بمفهوم أوسع هو **\"الاعتمادية\" (Dependability)**. وتُعرّف الشريحة أربعة خصائص رئيسية تُستخدم لتوصيف هذه \"الاعتمادية\" وهي: **الإتاحة (Availability)، الموثوقية (Reliability)، السلامة (Safety)، وقابلية الصيانة (Maintainability)**.",
    "details_and_text": [
      {
        "text_en": "\"Availability – the system is ready to be used immediately.\"",
        "explanation_ar": "**الإتاحة (Availability):** هي مقياس لاحتمالية أن يكون النظام قيد التشغيل وجاهزًا لتقديم الخدمة في أي لحظة معينة."
      },
      {
        "text_en": "\"Reliability – the system can run continuously without failure.\"",
        "explanation_ar": "**الموثوقية (Reliability):** هي مقياس لاستمرارية الخدمة. أي قدرة النظام على العمل لفترة طويلة من الزمن دون أن يتعرض للفشل."
      },
      {
        "text_en": "\"Safety – if a system fails, nothing catastrophic will happen.\"",
        "explanation_ar": "**السلامة (Safety):** تركز على العواقب. تضمن عدم حدوث نتائج كارثية أو ضارة (مثل إلحاق ضرر بالبيئة أو حياة البشر) حتى لو حدث فشل."
      },
      {
        "text_en": "\"Maintainability – when a system fails, it can be repaired easily and quickly (and, sometimes, without its users noticing the failure).\"",
        "explanation_ar": "**قابلية الصيانة (Maintainability):** هي سهولة وسرعة إصلاح النظام بعد الفشل، وأحيانًا يتم الإصلاح دون أن يلاحظ المستخدمون الفشل."
      }
    ],
    "questions_en_ar": {
      "a_current_slide_qa": [
        {
          "type": "Multiple Choice",
          "question_en": "A system that is ready to be used immediately is characterized by high:",
          "options": [
            "(a) Reliability",
            "(b) Safety",
            "(c) Availability",
            "(d) Maintainability"
          ],
          "answer_en": "(c) Availability",
          "explanation_ar": "الإتاحة (Availability) تعني أن النظام جاهز للاستخدام في الحال."
        },
        {
          "type": "True/False",
          "question_en": "Safety focuses on ensuring the system can run continuously without any downtime.",
          "answer_en": "False",
          "explanation_ar": "العبارة خاطئة. هذا هو تعريف الموثوقية (Reliability). السلامة (Safety) تركز على منع حدوث أي شيء كارثي حتى لو فشل النظام."
        }
      ],
      "b_previous_slides": [
        {
          "question_ar": "بالرجوع إلى الشريحة 3، تحمل الأخطاء هو \"متطلب غير وظيفي\". هل يمكنك تحديد خاصيتين من خصائص \"الاعتمادية\" الأربعة التي تعتبر الأكثر أهمية في تصميم نظام يتحمل الأخطاء؟",
          "hint_ar": "**الموثوقية** (لضمان الاستمرارية) و**السلامة** (لمنع الكوارث) هما الأكثر أهمية."
        },
        {
          "question_ar": "إذا كان لديك نظام حاسوبي لغرفة تحكم نووية. أي خاصية من خصائص الاعتمادية الأربعة هي الأكثر أهمية بالنسبة لك في هذا النظام؟ ولماذا؟",
          "hint_ar": "**السلامة (Safety)** هي الأهم لمنع النتائج الكارثية في حال فشل النظام."
        }
      ]
    }
  },
  {
    "slide_number": 5,
    "slide_title_ar": "أنواع الأعطال (Types of Fault)",
    "slide_title_en": "Types of Fault",
    "general_summary_ar": "تُصنّف هذه الشريحة الأعطال (**Faults**)، التي تم تعريفها في الشريحة 2 كأسباب جذرية للأخطاء، إلى ثلاثة أنواع رئيسية بناءً على سلوكها واستمراريتها في النظام. هذا التصنيف أمر بالغ الأهمية عند تصميم أنظمة **تحمل الأخطاء**، لأن طريقة معالجة كل نوع تختلف عن الأخرى.",
    "details_and_text": [
      {
        "text_en": "A **transient fault** starts at a particular time, remains in the system for some period and then disappears. E.g. hardware components which have an adverse reaction to radioactivity Many faults in communication systems are transient",
        "explanation_ar": "**العطل العابر (Transient Fault):** هو عطل مؤقت يحدث لمرة واحدة ويزول تلقائياً من النظام بعد فترة قصيرة. سببه غالباً عوامل خارجية مؤقتة (مثل التشويش الكهرومغناطيسي أو الإشعاع). هذا النوع هو الأكثر شيوعاً في أنظمة الاتصالات."
      },
      {
        "text_en": "**Intermittent faults** are transient faults that occur from time to time. E.g. a hardware component that is heat sensitive, it works for a time, stops working, cools down and then starts to work again",
        "explanation_ar": "**العطل المتقطع (Intermittent Fault):** هو عطل عابر لكنه يتكرر بشكل غير منتظم أو غير متوقع. يظهر ويختفي بسبب ظروف معينة مثل ارتفاع درجة الحرارة. هذا النوع أصعب في التشخيص."
      },
      {
        "text_en": "**Permanent faults** repeatable error, E.g. failed component, a broken wire, power fail, fire, flood, design error. Remain in the system until they are repaired",
        "explanation_ar": "**العطل الدائم (Permanent Fault):** هو عطل مستمر وثابت لا يزول من تلقاء نفسه، ويؤدي إلى خطأ يمكن تكراره. **أمثلته** تشمل: مكون تالف (failed component)، سلك مقطوع، انقطاع في التيار الكهربائي، حريق، فيضان، أو خطأ في تصميم النظام. هذا العطل **يبقى في النظام حتى يتم إصلاحه** يدوياً."
      }
    ],
    "questions_en_ar": {
      "a_current_slide_qa": [
        {
          "type": "Multiple Choice",
          "question_en": "A fault that disappears after a short time without repeating is called:",
          "options": [
            "(a) Intermittent fault",
            "(b) Permanent fault",
            "(c) Transient fault",
            "(d) System failure"
          ],
          "answer_en": "(c) Transient fault",
          "explanation_ar": "العطل العابر (Transient fault) هو الذي يظهر ويختفي لمرة واحدة."
        },
        {
          "type": "True/False",
          "question_en": "An intermittent fault is typically easier to diagnose than a permanent fault because it only happens once.",
          "answer_en": "False",
          "explanation_ar": "العبارة خاطئة. العطل المتقطع (Intermittent) يتكرر بشكل غير منتظم، مما يجعله أصعب في التشخيص."
        }
      ],
      "b_previous_slides": [
        {
          "question_ar": "ما هو النوع من الأعطال الثلاثة (عابر، متقطع، دائم) الذي يتطلب أعلى مستوى من خاصية **قابلية الصيانة (Maintainability)** (الشريحة 4)؟ ولماذا؟",
          "hint_ar": "**العطل الدائم (Permanent Fault)**، لأنه يتطلب استبدال أو إصلاحاً فعلياً للمكون."
        },
        {
          "question_ar": "بالرجوع إلى تعريف **تحمل الأخطاء** (الشريحة 3)، أي نوع من الأعطال تعتقد أنه الأكثر شيوعاً في أنظمة الاتصالات الحديثة؟ وكيف يمكن للنظام تحمل هذا النوع؟",
          "hint_ar": "الأعطال **العابرة** هي الأكثر شيوعاً، وتُتَحَمَّل عادةً من خلال إعادة المحاولة (retrying) أو التكرار (redundancy)."
        }
      ]
    }
  },
  {
    "slide_number": 6,
    "slide_title_ar": "مصطلحات تحمل الأخطاء (Terminology of Fault Tolerance)",
    "slide_title_en": "Terminology of Fault Tolerance",
    "general_summary_ar": "تُعد هذه الشريحة بمثابة ملخص ومراجعة للمفاهيم الجوهرية التي تم تعريفها في الشرائح السابقة (العطل، الخطأ، الفشل، تحمل الأخطاء). وتقدم الشريحة هذه المفاهيم في إطار رسم بياني يوضح العلاقة السببية بينها، بالإضافة إلى إعادة تعريف كل مصطلح بشكل رسمي.",
    "details_and_text": [
      {
        "text_en": "Fault  causes  Error  results in  Failure ",
        "explanation_ar": "يوضح هذا المخطط التسلسل السببي: **العطل (Fault)** هو الذي **يُسبب (causes)** **الخطأ (Error)**، والذي بدوره **يؤدي إلى (results in)** **الفشل (Failure)**."
      },
      {
        "text_en": "Fault – is a defect within the system. ",
        "explanation_ar": "**العطل** هو عيب أو خلل موجود داخل مكونات النظام (سواء كان عتاداً مادياً أو برنامجاً)."
      },
      {
        "text_en": "Error – is observed by a deviation from the expected behavior of the system. ",
        "explanation_ar": "**الخطأ** هو انحراف يُلاحظ في سلوك النظام عن السلوك المتوقع أو الصحيح. هذا الانحراف هو الحالة الداخلية غير الصحيحة التي تسبق الفشل."
      },
      {
        "text_en": "Failure occurs when the system can no longer perform as required (does not meet specifications). ",
        "explanation_ar": "**الفشل** يحدث عندما يعجز النظام عن أداء وظيفته المطلوبة (أي لا يلبي المواصفات المحددة له)، وهي النتيجة الخارجية للخطأ."
      },
      {
        "text_en": "Fault Tolerance – is ability of system to provide a service, even in the presence of errors. ",
        "explanation_ar": "**تحمل الأخطاء** هو قدرة النظام على الاستمرار في تقديم الخدمة المطلوبة، حتى مع وجود الأخطاء الداخلية (Errors)."
      }
    ],
    "questions_en_ar": {
      "a_current_slide_qa": [
        {
          "type": "Multiple Choice",
          "question_en": "What is the term for a **defect** within the system:",
          "options": [
            "(a) Failure",
            "(b) Error",
            "(c) Fault",
            "(d) Dependability"
          ],
          "answer_en": "(c) Fault",
          "explanation_ar": "الإجابة هي (c) لأن العطل (Fault) يُعرَّف بأنه العيب أو الخلل الأولي داخل النظام."
        },
        {
          "type": "True/False",
          "question_en": "A deviation from the expected behavior of the system is called a Failure.",
          "answer_en": "False",
          "explanation_ar": "العبارة خاطئة. الانحراف عن السلوك المتوقع يُسمى **خطأ (Error)**، أما **الفشل (Failure)** فهو النتيجة النهائية عندما يتوقف النظام عن الأداء المطلوب."
        }
      ],
      "b_previous_slides": [
        {
          "question_ar": "ما هي الخاصية من خصائص **الاعتمادية (Dependability)** (الشريحة 4) التي تُعالج بشكل مباشر منع **الفشل (Failure)** الذي له نتائج كارثية؟",
          "hint_ar": "**السلامة (Safety)** هي التي تمنع النتائج الكارثية."
        },
        {
          "question_ar": "بالنظر إلى أنواع الأعطال (الشريحة 5: العابر، المتقطع، الدائم)، ما هو النوع الذي يتطلب إجراءات **تحمل أخطاء** تعتمد على التكرار الزمني (Time Redundancy)؟",
          "hint_ar": "**العطل العابر (Transient Fault)**، لأن التكرار الزمني مفيد لاكتشاف الأعطال التي تزول بمرور الوقت."
        }
      ]
    }
  },
  {
    "slide_number": [
      7,
      8,
      9
    ],
    "slide_title_ar": "أنواع الأخطاء (Types of Errors)",
    "slide_title_en": "Types of Errors",
    "general_summary_ar": "تنتقل هذه الشريحة إلى تصنيف **الأخطاء (Errors)**، وهي الانحرافات الداخلية التي يسببها العطل (Fault). تبدأ الشريحة بتعريف النوع الأبسط والأقل احتمالاً في النقل التسلسلي، وهو **خطأ البت الواحد (Single-bit error)**، وتوضح سبب ندرته في هذا النوع من الإرسال مقارنة بالإرسال المتوازي.",
    "details_and_text": [
      {
        "text_en": "Single-bit error [cite: 40] when only one bit in the data unit has changed.",
        "explanation_ar": "**خطأ البت الواحد (Single-bit error):** يحدث هذا الخطأ عندما يتغير بت واحد فقط (من 0 إلى 1 أو العكس) ضمن وحدة البيانات المرسلة."
      },
      {
        "text_en": "Single bit errors are the least likely type of errors in serial data transmission because the noise must have a very short duration which is very rare.",
        "explanation_ar": "يُعد خطأ البت الواحد هو **الأقل احتمالية** في إرسال البيانات التسلسلي (Serial Transmission). والسبب هو أن الضوضاء يجب أن تكون قصيرة جداً في مدتها الزمنية."
      },
      {
        "text_en": "However this kind of errors can happen in parallel transmission.",
        "explanation_ar": "هذا النوع من الأخطاء يمكن أن يحدث بسهولة أكبر في الإرسال **المتوازي (Parallel transmission)**."
      },
      {
        "text_en": "Example: If data is sent at 1Mbps then each bit lasts only 1/1,000,000 sec. or 1 μs. For a single-bit error to occur, the noise must have a duration of only 1 μs, which is very rare.",
        "explanation_ar": "لتوضيح ندرة الحدوث: إذا كان معدل الإرسال **1 ميغابت في الثانية (Mbps)**، فإن البت الواحد يستغرق **1 ميكروثانية **. لكي يحدث خطأ البت الواحد، يجب أن تكون مدة الضوضاء 1 ميكروثانية فقط، وهو أمر نادر الحدوث."
      }
    ],
    "questions_en_ar": {
      "a_current_slide_qa": [
        {
          "type": "True/False",
          "question_en": "Single-bit errors are the most likely type of error in serial data transmission.",
          "answer_en": "False",
          "explanation_ar": "العبارة خاطئة. الشريحة تنص على أنها **الأقل احتمالية (least likely)** في الإرسال التسلسلي لأن الضوضاء يجب أن تكون قصيرة جداً."
        },
        {
          "type": "Multiple Choice",
          "question_en": "A single-bit error is easier to occur in which type of data transmission:",
          "options": [
            "(a) Serial transmission",
            "(b) Parallel transmission",
            "(c) Fiber optic transmission",
            "(d) Analog transmission"
          ],
          "answer_en": "(b) Parallel transmission",
          "explanation_ar": "الإجابة هي (b) حيث تشير الشريحة إلى أن هذا النوع من الأخطاء يمكن أن يحدث في الإرسال المتوازي."
        }
      ],
      "b_previous_slides": [
        {
          "question_ar": "إذا حدث **خطأ بت واحد (Single-bit error)**، هل يمكن اعتباره ناتجاً عن **عطل عابر (Transient Fault)** (الشريحة 5)؟",
          "hint_ar": "نعم، لأن خطأ البت الواحد عادة ما ينتج عن **ضوضاء (Noise)** وهي عامل خارجي عابر ومؤقت، وهو تعريف العطل العابر."
        },
        {
          "question_ar": "في سياق **الاعتمادية (Dependability)** (الشريحة 4)، لماذا تُعد القدرة على اكتشاف **أخطاء البت الواحد** وتصحيحها مهمة لتحقيق خاصية **الموثوقية (Reliability)**؟",
          "hint_ar": "لأن الموثوقية تتعلق باستمرارية التشغيل دون فشل، وتصحيح الأخطاء الصغيرة يمنع تحولها إلى فشل في الخدمة."
        }
      ]
    }
  },
  {
    "slide_number": 10,
    "slide_title_ar": "خطأ البت المتعدد (Multiple-Bit Error)",
    "slide_title_en": "Multiple-Bit Error",
    "general_summary_ar": "تُعرّف هذه الشريحة النوع الأول من الأخطاء التي تتجاوز خطأ البت الواحد، وهو **خطأ البت المتعدد (Multiple-Bit Error)**، مع التركيز على حالة عدم تجاور البتات التالفة.",
    "details_and_text": [
      {
        "text_en": "when two or more nonconsecutive bits in the data unit have changed.",
        "explanation_ar": "**خطأ البت المتعدد:** يحدث عندما يتغير بتان أو أكثر ضمن وحدة البيانات، وتكون هذه البتات **غير متجاورة** (nonconsecutive) في التسلسل. ",
        "image_context": "يوضح الرسم البياني بتين غير متجاورين تغيرتا في الإرسال (البت الثاني والخامس في المثال)."
      }
    ],
    "questions_en_ar": {
      "a_current_slide_qa": [
        {
          "type": "Multiple Choice",
          "question_en": "What is the minimum number of changed bits required for a Multiple-Bit Error?",
          "options": [
            "(a) One bit",
            "(b) Two bits",
            "(c) Three bits",
            "(d) Four bits"
          ],
          "answer_en": "(b) Two bits",
          "explanation_ar": "الإجابة هي (b) لأن التعريف يشير إلى 'بتين أو أكثر'."
        },
        {
          "type": "True/False",
          "question_en": "In a Multiple-Bit Error, the changed bits must be adjacent (consecutive).",
          "answer_en": "False",
          "explanation_ar": "العبارة خاطئة. الشريحة تنص صراحة على أنها بتات **غير متجاورة (nonconsecutive)**."
        }
      ],
      "b_previous_slides": [
        {
          "question_ar": "هل يمكن لـ **خطأ بت متعدد** أن يكون نتيجة لـ **عطل عابر (Transient Fault)** (الشريحة 5)؟",
          "hint_ar": "نعم، لأن أي ضوضاء (Noise) عابرة وطويلة بما فيه الكفاية يمكن أن تؤدي إلى تغيير بتين أو أكثر."
        }
      ]
    }
  },
  {
    "slide_number": 11,
    "slide_title_ar": "خطأ الدفعة (Burst Error)",
    "slide_title_en": "Burst Error",
    "general_summary_ar": "تُقدم هذه الشريحة التعريف البصري والأساسي لـ **خطأ الدفعة (Burst Error)**، وهو النوع الأكثر شيوعاً في الإرسال التسلسلي، مع إظهار حالة تجاور البتات التالفة في مثال مصور.",
    "details_and_text": [
      {
        "text_en": "means that 2 or more consecutive bits in the data unit have changed",
        "explanation_ar": "**خطأ الدفعة:** يحدث عندما يتغير بتان أو أكثر من البتات المتجاورة (consecutive) في وحدة البيانات. ",
        "image_context": "يوضح الرسم البياني مثالاً على خطأ دفعة حيث تغيرت أربعة بتات متجاورة."
      }
    ],
    "questions_en_ar": {
      "a_current_slide_qa": [
        {
          "type": "True/False",
          "question_en": "A Burst Error must always affect exactly two bits.",
          "answer_en": "False",
          "explanation_ar": "العبارة خاطئة. خطأ الدفعة يؤثر على 'بتين أو أكثر'."
        },
        {
          "type": "Definition",
          "question_en": "If 5 adjacent bits in a data unit change their values, is this considered a Burst Error?",
          "answer_en": "Yes",
          "explanation_ar": "نعم، لأنه ينطبق عليه تعريف خطأ الدفعة: 'بتين أو أكثر متجاورين'."
        }
      ],
      "b_previous_slides": [
        {
          "question_ar": "لماذا يُعد **خطأ الدفعة** أكثر خطورة على **الموثوقية (Reliability)** (الشريحة 4) من **خطأ البت الواحد** (الشريحة 7)؟",
          "hint_ar": "لأنه يفسد قدراً أكبر من البيانات، مما يزيد من احتمالية حدوث فشل في النظام."
        }
      ]
    }
  },
  {
    "slide_number": 12,
    "slide_title_ar": "خطأ الدفعة - تعريف القياس (Burst Error - Measurement Definition)",
    "slide_title_en": "Burst Error - Measurement Definition",
    "general_summary_ar": "تُوضح هذه الشريحة تعريفاً أكثر دقة لـ **خطأ الدفعة**، وتصحح المفهوم الخاطئ بأن الأخطاء يجب أن تكون متجاورة، مؤكدة على أن القياس الفعلي لخطأ الدفعة يعتمد على **طوله (length)** بين أول وآخر بت تالف.",
    "details_and_text": [
      {
        "text_en": "The term burst error means that two or more bits in the data unit have changed from 1 to 0 or from 0 to 1.",
        "explanation_ar": "التعريف العام: **خطأ الدفعة** يعني أن بتين أو أكثر في وحدة البيانات قد تغيرتا قيمتهما. "
      },
      {
        "text_en": "Burst errors does not necessarily mean that the errors occur in consecutive bits, the length of the burst is measured from the first corrupted bit to the last corrupted bit.",
        "explanation_ar": "لا يشترط أن تكون الأخطاء متجاورة. ويُقاس **طول الدفعة** من أول بت تالف إلى آخر بت تالف."
      }
    ],
    "questions_en_ar": {
      "a_current_slide_qa": [
        {
          "type": "Scenario",
          "question_en": "If a 10-bit unit has errors only at position 2 and position 9. What is the length of the burst error?",
          "answer_en": "8 bits",
          "explanation_ar": "الطول يُقاس من البت الأول التالف (2) إلى البت الأخير التالف (9): $9 - 2 + 1 = 8$ بت."
        },
        {
          "type": "True/False",
          "question_en": "If a 20-bit burst error occurs, it means exactly 20 bits have been flipped from 0 to 1 or vice versa.",
          "answer_en": "False",
          "explanation_ar": "العبارة خاطئة. الطول يشمل البتات السليمة بين أول وآخر بت تالف، لذا لا يلزم أن تكون جميع الـ 20 بتاً قد تغيرت."
        }
      ],
      "b_previous_slides": [
        {
          "question_ar": "ما هو النوع من الأعطال (الشريحة 5) الذي من المرجح أن يسبب خطأ دفعة بطول كبير؟",
          "hint_ar": "**العطل العابر (Transient Fault)**، خاصة إذا كان على شكل ضوضاء قوية وطويلة الأمد."
        }
      ]
    }
  },
  {
    "slide_number": 13,
    "slide_title_ar": "خطأ الدفعة - الاحتمالية والأمثلة الحسابية (Burst Error - Probability and Calculation)",
    "slide_title_en": "Burst Error - Probability and Calculation",
    "general_summary_ar": "تُركز هذه الشريحة على تبرير سبب كون **خطأ الدفعة (Burst Error)** هو النوع **الأكثر احتمالاً (most likely)** للحدوث في **الإرسال التسلسلي (serial transmission)**، وتقدم أمثلة حسابية توضح كيف يعتمد عدد البتات المتأثرة على **معدل البيانات (Data Rate)** و **مدة الضوضاء (Duration of Noise)**.",
    "details_and_text": [
      {
        "text_en": "Burst error is most likely to happen in serial transmission since the duration of noise is normally longer than the duration of a bit.",
        "explanation_ar": "خطأ الدفعة هو الأكثر احتمالية في الإرسال التسلسلي. **السبب:** مدة الضوضاء تكون عادةً أطول من مدة البت الواحد، مما يؤدي إلى تلف عدة بتات. "
      },
      {
        "text_en": "The number of bits affected depends on the data rate and duration of noise.",
        "explanation_ar": "عدد البتات المتأثرة يعتمد على عاملين: **معدل البيانات (Data Rate)** و **مدة الضوضاء (Duration of Noise)**. "
      },
      {
        "text_en": "Example: If data is sent at rate = 1Kbps then a noise of 1/100 sec can affect 10 bits.(1/100*1000)",
        "explanation_ar": "عند معدل $1Kbps$: ضوضاء $1/100$ ثانية تؤثر على **10 بتات**. [cite: 579]"
      },
      {
        "text_en": "If same data is sent at rate = 1Mbps then a noise of 1/100 sec can affect 10,000 bits.(1/100*10^6)",
        "explanation_ar": "عند معدل $1Mbps$: نفس الضوضاء تؤثر على **10,000 بت**. [cite: 580] (مما يوضح خطورة ارتفاع معدل البيانات)."
      }
    ],
    "questions_en_ar": {
      "a_current_slide_qa": [
        {
          "type": "True/False",
          "question_en": "Increasing the data rate while keeping the noise duration constant will decrease the number of affected bits in a burst error.",
          "answer_en": "False",
          "explanation_ar": "العبارة خاطئة. زيادة معدل البيانات يزيد من عدد البتات المتأثرة لنفس مدة الضوضاء."
        },
        {
          "type": "Calculation",
          "question_en": "If data is sent at a rate of 2 Mbps and a noise pulse lasts for 0.0001 sec, how many bits could be affected?",
          "answer_en": "200 bits",
          "explanation_ar": "عدد البتات المتأثرة = $(2 \times 10^6 \text{ بت/ث}) \times (10^{-4} \text{ ثانية}) = 200 \text{ بت}$."
        }
      ],
      "b_previous_slides": [
        {
          "question_ar": "في سياق **تحمل الأخطاء (Fault Tolerance)** (الشريحة 3)، لماذا تعتبر هذه الشريحة نقطة حاسمة في تصميم بروتوكولات الاتصالات؟",
          "hint_ar": "لأنها تحدد طبيعة التحدي (وهو الأخطاء الكبيرة)، وبالتالي يجب أن تُصمم آليات تحمل الأخطاء (كالتشفير التصحيحي) لتكون قادرة على معالجة عدد كبير من البتات التالفة."
        }
      ]
    }
  },
  {
    "slide_number": 14,
    "slide_title_ar": "استراتيجيات تحمل الأخطاء (Fault Tolerant Strategies)",
    "slide_title_en": "Fault Tolerant Strategies",
    "general_summary_ar": "توضح هذه الشريحة أن تحمل الأخطاء يتم تحقيقه عبر **التكرار (Redundancy)** بأشكاله المختلفة (مادي، برمجي، معلوماتي، زمني)، وتُعرّف طريقتين تقنيتين مهمتين: إخفاء الأخطاء (Fault Masking) وإعادة التشكيل (Reconfiguration).",
    "details_and_text": [
      {
        "text_en": "Fault tolerance in computer system is achieved through redundancy in hardware, software, information, and/or computations Time. Such redundancy can be implemented in static, dynamic, or hybrid configurations.",
        "explanation_ar": "يتم تحقيق تحمل الأخطاء من خلال **التكرار** بأشكاله المختلفة (مادي، برمجي، معلوماتي، زمني). يمكن تطبيق التكرار في تكوينات ثابتة (Static)، ديناميكية (Dynamic)، أو هجينة (Hybrid)."
      },
      {
        "text_en": "Fault masking is any process that prevents faults in a system from introducing errors. Example: Error correcting memories and majority voting.",
        "explanation_ar": "**إخفاء الأخطاء (Fault Masking):** هي عملية تمنع العطل من التسبب في ظهور خطأ واضح، وتعتمد على التكرار الثابت (مثل ذاكرة تصحيح الأخطاء والتصويت بالأغلبية)."
      },
      {
        "text_en": "Reconfiguration is the process of eliminating faulty component from a system and restoring the system to some operational state.",
        "explanation_ar": "**إعادة التشكيل (Reconfiguration):** هي عملية عزل المكون المعيب من النظام، ومن ثم إعادة تشغيله أو تعديل تكوينه للوصول إلى حالة تشغيل مقبولة."
      }
    ],
    "questions_en_ar": {
      "a_current_slide_qa": [
        {
          "type": "True/False",
          "question_en": "Fault Masking typically relies on a Dynamic Redundancy approach.",
          "answer_en": "False",
          "explanation_ar": "العبارة خاطئة. إخفاء الأخطاء (مثل التصويت بالأغلبية) هو مثال كلاسيكي على التكرار الثابت (Static Redundancy)."
        },
        {
          "type": "Definition",
          "question_en": "Which strategy involves isolating a failed component and continuing operation?",
          "answer_en": "Reconfiguration (إعادة التشكيل)",
          "explanation_ar": "إعادة التشكيل هي عملية إزالة المكون الفاشل وإعادة النظام للعمل بوضعية جديدة."
        }
      ],
      "b_previous_slides": [
        {
          "question_ar": "إذا حدث **خطأ بت واحد (Single-bit Error)** (الشريحة 7)، فأي تقنية من الشريحة 14 ستكون الأكثر سرعة وكفاءة للتعامل معه في الذاكرة؟",
          "hint_ar": "**إخفاء الأخطاء (Fault Masking)**، باستخدام ذاكرة تصحيح الأخطاء التي تعالج الخطأ فوراً دون مقاطعة النظام."
        }
      ]
    }
  },
  {
    "slide_number": 15,
    "slide_title_ar": "مراحل معالجة الأعطال (Fault Handling Processes)",
    "slide_title_en": "Fault Handling Processes",
    "general_summary_ar": "تُركز هذه الشريحة على الخطوات المتسلسلة التي يتبعها النظام للتعامل مع العطل بمجرد حدوثه، بدءًا من الاكتشاف وصولاً إلى التعافي، وهي الأساس لتطبيق استراتيجية تحمل الأخطاء.",
    "details_and_text": [
      {
        "text_en": "Fault detection is the process of recognizing that a fault has occurred. Fault detection is often required before any recovery procedure can be initiated.",
        "explanation_ar": "**اكتشاف الأعطال (Fault Detection):** عملية التعرف على أن عطلاً قد حدث. هي خطوة ضرورية قبل البدء بأي إجراء للتعافي."
      },
      {
        "text_en": "Fault location is the process of determining where a fault has occurred so that an appropriate recovery can be initiated.",
        "explanation_ar": "**تحديد موقع العطل (Fault Location):** عملية تحديد المكان الدقيق أو المكون المسؤول عن العطل لضمان تطبيق إجراء التعافي الصحيح."
      },
      {
        "text_en": "Fault Isolating is the process of isolating a fault and preventing the effects of that fault from propagating throughout the system.",
        "explanation_ar": "**عزل العطل (Fault Isolating):** عملية فصل المكون المعيب لمنع تأثيره من الانتشار إلى باقي الأجزاء السليمة في النظام."
      },
      {
        "text_en": "Fault recovery is the process of remaining operational or regaining operational status via reconfiguration even in the presence of faults",
        "explanation_ar": "**التعافي من العطل (Fault Recovery):** عملية استعادة أو الحفاظ على حالة التشغيل حتى في وجود الأعطال، غالبًا من خلال **إعادة التشكيل (Reconfiguration)**."
      }
    ],
    "questions_en_ar": {
      "a_current_slide_qa": [
        {
          "type": "Sequence",
          "question_en": "Arrange the following steps in the correct order: Recovery, Location, Detection, Isolating.",
          "answer_en": "Detection → Location → Isolating → Recovery.",
          "explanation_ar": "التسلسل يبدأ بالتعرف على العطل، تحديد مكانه، عزله، والتعافي منه."
        },
        {
          "type": "Definition",
          "question_en": "Which process specifically aims to prevent a localized fault from damaging other components in the system?",
          "answer_en": "Fault Isolating",
          "explanation_ar": "عزل العطل هو الإجراء الذي يمنع انتشاره (Propagation) لباقي أجزاء النظام."
        }
      ],
      "b_previous_slides": [
        {
          "question_ar": "باستخدام مفهوم **إخفاء الأخطاء (Fault Masking)** (الشريحة 14)، هل لا يزال يتطلب النظام تمرير جميع مراحل معالجة الأعطال (Detection, Location, Isolating, Recovery)؟",
          "hint_ar": "لا، إخفاء الأخطاء يتجاوز مراحل Detection و Location و Isolating، حيث يتم التعافي أو 'الإخفاء' بشكل فوري دون تدخل المراحل الأخرى."
        }
      ]
    }
  },
  {
    "slide_number": 16,
    "slide_title_ar": "مفهوم وأنواع التكرار (The Concept of Redundancy)",
    "slide_title_en": "The Concept of Redundancy",
    "general_summary_ar": "تُعرّف هذه الشريحة التكرار كمبدأ أساسي لتحمل الأخطاء، ثم تُصنّفه إلى ثلاثة أنواع رئيسية: المعلوماتي (Information)، والزمني (Time)، والمادي (Hardware).",
    "details_and_text": [
      {
        "text_en": "Redundancy is simply the addition of information, resources, or time beyond what is needed for normal system operation.",
        "explanation_ar": "**التكرار:** هو إضافة معلومات، أو موارد، أو وقت، تتجاوز الحد الأدنى المطلوب للتشغيل العادي للنظام لتمكينه من تحمل الأخطاء."
      },
      {
        "text_en": "Information redundancy is the addition of extra information beyond that required to implement a given function; for example, error detection codes.",
        "explanation_ar": "**التكرار المعلوماتي:** إضافة معلومات إضافية (بتات تكرارية)؛ مثال: أكواد كشف الأخطاء."
      },
      {
        "text_en": "Time redundancy uses additional time to perform the functions of a system such that fault detection and often fault tolerance can be achieved. Transient faults are tolerated by this.",
        "explanation_ar": "**التكرار الزمني:** استخدام وقت إضافي لتكرار وظائف النظام. مناسب بشكل خاص لـ **الأعطال العابرة (Transient Faults)**."
      },
      {
        "text_en": "Hardware redundancy is the addition of extra hardware, usually for the purpose either detecting or tolerating faults.",
        "explanation_ar": "**التكرار المادي:** إضافة أجهزة إضافية (مثل مكونات احتياطية) لغرض اكتشاف أو تحمل الأعطال."
      }
    ],
    "questions_en_ar": {
      "a_current_slide_qa": [
        {
          "type": "Multiple Choice",
          "question_en": "Which type of redundancy is primarily concerned with repeating a process to overcome temporary data corruption:",
          "options": [
            "(a) Information redundancy",
            "(b) Hardware redundancy",
            "(c) Time redundancy",
            "(d) Fault avoidance"
          ],
          "answer_en": "(c) Time redundancy",
          "explanation_ar": "التكرار الزمني هو إعادة العملية في فترة زمنية لاحقة للتغلب على الأعطال العابرة."
        },
        {
          "type": "Definition",
          "question_en": "Give an example of Information Redundancy.",
          "answer_en": "Error detection codes (مثل Parity Check أو CRC).",
          "explanation_ar": "أكواد كشف الأخطاء هي معلومات إضافية تُضاف للبيانات الأصلية."
        }
      ],
      "b_previous_slides": [
        {
          "question_ar": "في الشريحة 14، ذكرنا تقنية **إخفاء الأخطاء (Fault Masking)**. أي من أنواع التكرار (Information, Time, Hardware) يمكن استخدامه لتحقيق إخفاء الأخطاء؟",
          "hint_ar": "كلاهما **التكرار المعلوماتي** (باستخدام أكواد تصحيح الأخطاء القوية) و**التكرار المادي** (باستخدام التصويت بالأغلبية)."
        }
      ]
    }
  },
  {
    "slide_number": 17,
    "slide_title_ar": "التكرار البرمجي وتأثير التكرار العام (Software Redundancy and General Impact)",
    "slide_title_en": "Software Redundancy and General Impact",
    "general_summary_ar": "تُعرّف هذه الشريحة **التكرار البرمجي**، ثم تُسلّط الضوء على **التكلفة** والتبعات السلبية التي يجب موازنتها عند تطبيق أي شكل من أشكال التكرار.",
    "details_and_text": [
      {
        "text_en": "Software redundancy is the addition of extra software, beyond what is needed to perform a given function, to detect and possibly tolerate faults.",
        "explanation_ar": "**التكرار البرمجي:** إضافة كود أو خوارزميات إضافية تتجاوز الحد الأدنى المطلوب لأداء الوظيفة الأساسية، بهدف اكتشاف وتحمل الأعطال. مثال: التنفيذ المتعدد للنسخ (N-Version Programming)."
      },
      {
        "text_en": "The use of redundancy can provide additional capabilities within a system. But, redundancy can have very important impact on a system's performance, size, weight, power consumption, and reliability.",
        "explanation_ar": "**تأثير التكرار:** التكرار يمنح قدرات تحمل الأخطاء، ولكنه يؤثر سلباً على **الأداء**، ويزيد من **الحجم والوزن** و**استهلاك الطاقة**. قد يؤثر أيضاً على **الموثوقية** بسبب زيادة نقاط الفشل الكلية."
      }
    ],
    "questions_en_ar": {
      "a_current_slide_qa": [
        {
          "type": "Multiple Choice",
          "question_en": "Which factor is generally *not* negatively impacted by the addition of redundancy:",
          "options": [
            "(a) Power Consumption",
            "(b) Size",
            "(c) Fault Tolerance",
            "(d) Performance"
          ],
          "answer_en": "(c) Fault Tolerance",
          "explanation_ar": "تحمل الأخطاء هو الهدف الأساسي من التكرار، وبالتالي هو الشيء الوحيد الذي يجب أن يتحسن وليس يتأثر سلباً."
        },
        {
          "type": "Definition",
          "question_en": "What is the primary purpose of adding extra software in Software Redundancy?",
          "answer_en": "To detect and possibly tolerate faults.",
          "explanation_ar": "اكتشاف وتحمل الأعطال هو هدف الكود الإضافي."
        }
      ],
      "b_previous_slides": [
        {
          "question_ar": "إذا استخدمنا تقنية **التصويت بالأغلبية (Majority Voting)** (الشريحة 14)، فما هو التأثير السلبي الأوضح الذي سيظهر من القائمة المذكورة في الشريحة 17؟",
          "hint_ar": "زيادة **استهلاك الطاقة** و**الحجم/الوزن**، لأن التصويت بالأغلبية يتطلب مضاعفة الأجهزة."
        }
      ]
    }
  },
  {
    "slide_number": 18,
    "slide_title_ar": "إخفاء الفشل بالتكرار (Failure Masking by Redundancy)",
    "slide_title_en": "Failure Masking by Redundancy",
    "general_summary_ar": "توضح هذه الشريحة كيف تُستخدم الأنواع الثلاثة الرئيسية من التكرار (**المعلوماتي**، **الزمني**، و**المادي**) لتحقيق هدف **إخفاء الفشل (Failure Masking)**، أي منع العطل من التسبب في خطأ واضح يُعيق عمل النظام.",
    "details_and_text": [
      {
        "text_en": "Information Redundancy – add extra bits to allow for error detection/recovery (e.g., Hamming codes and the like).",
        "explanation_ar": "**التكرار المعلوماتي:** إضافة بتات إضافية تُمكّن من اكتشاف وتصحيح الأخطاء تلقائياً، مما يُخفي تأثير العطل. مثال: أكواد هامينغ."
      },
      {
        "text_en": "Time Redundancy – perform operation and, if needs be, perform it again.",
        "explanation_ar": "**التكرار الزمني:** إعادة تنفيذ العملية أو الإرسال. يُستخدم لإخفاء الأعطال العابرة التي تزول مع تكرار العملية."
      },
      {
        "text_en": "Hardware Redundancy :add extra (duplicate) hardware and/or software to the system.",
        "explanation_ar": "**التكرار المادي:** إضافة أجهزة مكررة أو برمجيات مكررة للنظام، مثل أنظمة التصويت بالأغلبية، لإخفاء فشل المكون الأساسي."
      }
    ],
    "questions_en_ar": {
      "a_current_slide_qa": [
        {
          "type": "Multiple Choice",
          "question_en": "If a system uses Hamming codes for error correction, which type of redundancy is it primarily relying on to mask the failure:",
          "options": [
            "(a) Time Redundancy",
            "(b) Information Redundancy",
            "(c) Hardware Redundancy",
            "(d) Fault Forecasting"
          ],
          "answer_en": "(b) Information Redundancy",
          "explanation_ar": "أكواد هامينغ هي تقنية تعتمد على إضافة معلومات (بتات تكرارية) لتصحيح الأخطاء."
        },
        {
          "type": "Definition",
          "question_en": "How does Time Redundancy mask a failure?",
          "answer_en": "By repeating the operation or transmission, which is effective against transient faults.",
          "explanation_ar": "التكرار الزمني يتيح للمحاولة الثانية أو اللاحقة أن تكون ناجحة إذا كان العطل مؤقتاً."
        }
      ],
      "b_previous_slides": [
        {
          "question_ar": "تقنية **إخفاء الأخطاء (Fault Masking)** (الشريحة 14) التي تم شرحها هنا، هل تتطلب مراحل **اكتشاف** و**عزل** العطل (الشريحة 15) بشكل صريح؟",
          "hint_ar": "لا، إخفاء الأخطاء هو تعافٍ فوري. يتم اكتشاف وتصحيح الخطأ في وقت واحد دون الحاجة لمراحل عزل أو إعادة تشكيل واضحة."
        }
      ]
    }
  },
  {
    "slide_number": [
      19,
      20
    ],
    "slide_title_ar": "مثال: تحمل الأخطاء في مكوك الفضاء (Space Shuttle)",
    "slide_title_en": "Example: Space Shuttle Fault Tolerance",
    "general_summary_ar": "تُعد هذه الشرائح دراسة حالة كلاسيكية لتطبيق مبادئ تحمل الأخطاء، حيث يوضح المثال كيف استخدم مكوك الفضاء خمسة حواسيب متطابقة لتوفير مستويات عالية من التكرار المادي وإخفاء الأخطاء.",
    "details_and_text": [
      {
        "text_en": "Uses 5 identical computers which can be assigned to redundant operation under program control.",
        "explanation_ar": "يستخدم المكوك 5 حواسيب متطابقة يمكن برمجتها للعمل بتكوينات تكرارية مختلفة."
      },
      {
        "text_en": "During critical mission phases - boost, re-entry and loading - 4 of its 5 computers operate an NMR configuration, receiving the same inputs and executing identical tasks. When a failure is detected the computer concerned is switched out of the system leaving a TMR arrangement.",
        "explanation_ar": "في المراحل الحرجة، تعمل 4 حواسيب بتكوين **NMR** (تكرار معياري N). عند اكتشاف عطل، يُعزل الحاسوب المعيب، ليتبقى تكوين **TMR** (تكرار ثلاثي معياري)."
      },
      {
        "text_en": "The fifth computer is used to perform non-critical tasks in a simplex mode, however, under extreme cases may take over critical functions. The unit has 'diverse' software and could be used if a systematic fault was discovered in the other four computers.",
        "explanation_ar": "الحاسوب الخامس يعمل لمهام غير حرجة، لكنه يحتوي على **برمجيات متنوعة (Diverse software)** لمواجهة **الأعطال المنهجية** التي قد تؤثر على الحواسيب الأربعة الأخرى."
      },
      {
        "text_en": "The shuttle can tolerate up to two computer failures; after a second failure it operates as a duplex system and uses comparison and self-test techniques to survive a third fault.",
        "explanation_ar": "يتحمل النظام فشل حاسوبين. بعد الفشل الثاني، يعمل كنظام **مزدوج (Duplex system)** ويستخدم المقارنة والاختبار الذاتي للبقاء في حالة تشغيل."
      }
    ],
    "questions_en_ar": {
      "a_current_slides_qa": [
        {
          "type": "Definition",
          "question_en": "Why is the fifth computer given Diverse Software?",
          "answer_en": "To protect the system against Systematic Faults (مثل أخطاء الكود البرمجي) التي قد تؤثر على جميع الحواسيب الأربعة الأخرى التي تشترك في نفس البرنامج.",
          "explanation_ar": "البرمجيات المتنوعة ضرورية للتحمل ضد الأخطاء المنهجية التي تنشأ من خطأ بشري في التصميم أو الكود."
        },
        {
          "type": "Scenario",
          "question_en": "If the system is operating in a TMR configuration and a fault is detected in one computer, what is the next operating configuration?",
          "answer_en": "Duplex System (نظام مزدوج)",
          "explanation_ar": "التكوين يبدأ بـ 4 (NMR)، بعد فشل 1 يصبح 3 (TMR)، وبعد فشل 2 يصبح 2 (Duplex)."
        }
      ],
      "b_previous_slides": [
        {
          "question_ar": "في سيناريو مكوك الفضاء، يتم تحقيق **إخفاء الأخطاء (Fault Masking)** (الشريحة 14) باستخدام أي تكوين تكراري؟",
          "hint_ar": "يتم تحقيقه باستخدام **NMR (4 حواسيب)** و **TMR (3 حواسيب)**، حيث يتم استخدام **التصويت** لإخفاء الخطأ الفردي."
        }
      ]
    }
  },
  {
    "slide_number": 22,
    "slide_title_ar": "التكرار الزمني",
    "slide_title_en": "Time Redundancy",
    "general_summary_ar": "تُركز هذه الشريحة على **التكرار الزمني** كوسيلة لكشف الأعطال المؤقتة من خلال إعادة تنفيذ العملية نفسها مرتين أو أكثر، مع مقارنة النتائج. تُبرز المزايا (قلة التكلفة المادية) والعيوب (تأثير على الأداء).",
    "details_and_text": [
      {
        "text_en": "Perform Same Operation Twice (or more)",
        "explanation_ar": "**تنفيذ العملية نفسها مرتين (أو أكثر):** يتم إعادة العملية الحسابية أو الإرسال للتحقق من النتيجة."
      },
      {
        "text_en": "See if get same result both times\nIf not, then fault occurred",
        "explanation_ar": "**مقارنة النتائج:** إذا كانت النتائج متطابقة، فالنظام سليم. إذا اختلفت، فهناك عطل حدث."
      },
      {
        "text_en": "Can detect temporary faults\nCannot detect permanent faults – Would affect both computations",
        "explanation_ar": "**يكشف الأعطال المؤقتة فقط:** الأعطال العابرة (transient) تظهر في محاولة واحدة فقط. أما الأعطال الدائمة (permanent) فتؤثر على كِلا التنفيذين، فلا يمكن كشفها بهذه الطريقة."
      },
      {
        "text_en": "Advantage\nLittle to no hardware overhead",
        "explanation_ar": "**الميزة:** تكلفة مادية (هاردوير) قليلة جدًا أو معدومة، حيث لا حاجة لمكونات إضافية."
      },
      {
        "text_en": "Disadvantage\nImpacts system or circuit performance",
        "explanation_ar": "**العيب:** يؤثر سلبًا على أداء النظام أو الدائرة بسبب زيادة الوقت اللازم لإتمام العمليات (ضعف السرعة تقريبًا)."
      }
    ],
    "questions_en_ar": {
      "a_current_slide_qa": [
        {
          "type": "Multiple Choice",
          "question_en": "What type of faults can Time Redundancy reliably detect when performing the same operation twice?",
          "options": [
            "(a) Temporary (transient) faults",
            "(b) Permanent faults",
            "(c) Intermittent faults only",
            "(d) All types of faults"
          ],
          "answer_en": "(a) Temporary (transient) faults",
          "explanation_ar": "الأعطال المؤقتة تظهر في تنفيذ واحد فقط، مما يؤدي إلى نتائج مختلفة عند المقارنة."
        },
        {
          "type": "Multiple Choice",
          "question_en": "Why does Time Redundancy fail to detect permanent faults?",
          "options": [
            "(a) It requires extra hardware",
            "(b) The fault affects only one execution",
            "(c) The fault corrupts both executions identically",
            "(d) It cannot compare results"
          ],
          "answer_en": "(c) The fault corrupts both executions identically",
          "explanation_ar": "العطل الدائم يؤثر على كِلا التنفيذين بنفس الطريقة، فتكون النتائج متطابقة (لكن خاطئة)، ولا يُكتشف العطل."
        },
        {
          "type": "Multiple Choice",
          "question_en": "What is the primary advantage of Time Redundancy?",
          "options": [
            "(a) High performance",
            "(b) Little to no hardware overhead",
            "(c) Detects all fault types",
            "(d) Automatic error correction"
          ],
          "answer_en": "(b) Little to no hardware overhead",
          "explanation_ar": "ميزته الأساسية هي عدم الحاجة إلى هاردوير إضافي، بل يعتمد على إعادة التنفيذ زمنيًا."
        },
        {
          "type": "Multiple Choice",
          "question_en": "Which of the following is a disadvantage of Time Redundancy?",
          "options": [
            "(a) High hardware cost",
            "(b) Impacts system performance",
            "(c) Cannot detect transient faults",
            "(d) Requires complex software"
          ],
          "answer_en": "(b) Impacts system performance",
          "explanation_ar": "يتطلب وقتًا إضافيًا لإعادة التنفيذ، مما يقلل من سرعة النظام."
        },
        {
          "type": "True/False",
          "question_en": "Time Redundancy requires significant additional hardware to function.",
          "options": [
            "True",
            "False"
          ],
          "answer_en": "False",
          "explanation_ar": "ميزته الأساسية هي عدم الحاجة إلى هاردوير إضافي، بل يعتمد على إعادة التنفيذ زمنيًا."
        },
        {
          "type": "Definition",
          "question_en": "How does Time Redundancy detect a fault?",
          "answer_en": "By comparing the results of two or more executions of the same operation; mismatch indicates a fault.",
          "explanation_ar": "يتم اكتشاف العطل عندما تكون نتائج التنفيذين مختلفتين، مما يشير إلى حدوث خطأ في إحدى المحاولتين."
        }
      ],
      "b_previous_slides": [
        {
          "question_ar": "كيف يرتبط **التكرار الزمني** (الشريحة 22) بمفهوم **إخفاء الفشل (Failure Masking)** الذي شُرح في الشريحة 18؟",
          "hint_ar": "التكرار الزمني يُستخدم أساسًا لـ **الكشف** وليس الإخفاء. في الإخفاء، يُصحح الخطأ فورًا دون إظهار تأثيره، بينما هنا يُكتشف العطل لكن لا يُصحح تلقائيًا."
        }
      ]
    }
  },
  {
    "slide_number": 23,
    "slide_title_ar": "التكرار الزمني - مخطط الدائرة",
    "slide_title_en": "Time Redundancy - Circuit Diagram",
    "general_summary_ar": "تُوضح هذه الشريحة تنفيذًا عمليًا للتكرار الزمني باستخدام تأخير زمني (d) بين تنفيذين متتاليين لنفس العملية، مع مقارنة النتائج لكشف الأعطال المؤقتة القصيرة. تُبرز انخفاض التكلفة المادية مع وجود عقوبة أداء تعتمد على قيمة التأخير (d).",
    "details_and_text": [
      {
        "text_en": "Combinational Logic",
        "explanation_ar": "**الدائرة المنطقية المدمجة:** تُنفّذ العملية الحسابية وتُنتج الإخراج بناءً على المدخلات."
      },
      {
        "text_en": "D Q (CK + d)",
        "explanation_ar": "**مُسجّل D-Flip-Flop (بساعة متأخرة CK + d):** يخزن الإخراج من التنفيذ السابق بعد تأخير زمني قدره d."
      },
      {
        "text_en": "D Q (CK)",
        "explanation_ar": "**مُسجّل D-Flip-Flop (بساعة حالية CK):** يخزن الإخراج من التنفيذ الحالي في الوقت الحقيقي."
      },
      {
        "text_en": "Comparator → Logic 1 indicates error",
        "explanation_ar": "**المقارن:** يقارن بين الإخراجين (الحالي والسابق). إذا اختلفت النتائج → يُخرج 1 (يُشير إلى وجود خطأ)."
      },
      {
        "text_en": "Hardware overhead is low.",
        "explanation_ar": "**تكلفة الأجهزة منخفضة:** لا يتطلب تكرار الدائرة المنطقية، فقط مُسجّل إضافي ومقارن بسيط."
      },
      {
        "text_en": "Performance penalty (~ d) = maximum detectable pulse width.",
        "explanation_ar": "**عقوبة الأداء (~ d) = أقصى عرض نبضة قابلة للكشف:** التأخير d يحدد الحد الأقصى لمدة التشويش القابل للكشف. النبضات الأطول من d قد لا تُكتشف."
      }
    ],
    "questions_en_ar": {
      "a_current_slide_qa": [
        {
          "type": "Multiple Choice",
          "question_en": "In the Time Redundancy circuit shown, what is the role of the delay 'd'?",
          "options": [
            "(a) To increase hardware complexity",
            "(b) To define the maximum detectable fault pulse width",
            "(c) To store the input data",
            "(d) To speed up the combinational logic"
          ],
          "answer_en": "(b) To define the maximum detectable fault pulse width",
          "explanation_ar": "التأخير d يحدد أقصى مدة للنبضة المؤقتة التي يمكن اكتشافها. إذا كانت النبضة أطول من d، فستؤثر على كِلا التنفيذين."
        },
        {
          "type": "Multiple Choice",
          "question_en": "What does a 'Logic 1' output from the comparator indicate?",
          "options": [
            "(a) The system is operating normally",
            "(b) A transient fault has been detected",
            "(c) The clock is delayed",
            "(d) The inputs have changed"
          ],
          "answer_en": "(b) A transient fault has been detected",
          "explanation_ar": "المقارن يُخرج 1 عندما تكون النتيجتان مختلفتين، مما يعني أن عطلًا مؤقتًا أثر على أحد التنفيذين."
        },
        {
          "type": "Multiple Choice",
          "question_en": "Why is the hardware overhead considered low in this design?",
          "options": [
            "(a) It uses two full copies of the combinational logic",
            "(b) It only adds one extra D Flip-Flop and a comparator",
            "(c) It eliminates the need for a clock",
            "(d) It uses analog components"
          ],
          "answer_en": "(b) It only adds one extra D Flip-Flop and a comparator",
          "explanation_ar": "لا يتم تكرار الدائرة المنطقية بالكامل، بل يُضاف فقط مُسجّل واحد إضافي ودائرة مقارنة بسيطة."
        },
        {
          "type": "Multiple Choice",
          "question_en": "Which type of fault might NOT be detected if its duration exceeds 'd'?",
          "options": [
            "(a) A transient fault shorter than d",
            "(b) A permanent stuck-at fault",
            "(c) A transient fault longer than d",
            "(d) An input error"
          ],
          "answer_en": "(c) A transient fault longer than d",
          "explanation_ar": "إذا استمر التشويش لأكثر من d، فسيؤثر على كِلا التنفيذين (الحالي والمتأخر)، فتتطابق النتائج الخاطئة ولا يُكتشف العطل."
        },
        {
          "type": "True/False",
          "question_en": "This Time Redundancy design can detect permanent faults effectively.",
          "options": [
            "True",
            "False"
          ],
          "answer_en": "False",
          "explanation_ar": "العطل الدائم سيؤثر على كِلا التنفيذين بنفس الطريقة، فتكون النتائج متطابقة (لكن خاطئة)، ولا يُكتشف."
        }
      ],
      "b_previous_slides": [
        {
          "question_ar": "ما الفرق بين نهج التكرار الزمني في الشريحة 22 (إعادة التنفيذ الكامل) والشريحة 23 (التأخير الزمني d)؟",
          "hint_ar": "الشريحة 22 تعيد التنفيذ من البداية (مكلفة زمنيًا)، بينما الشريحة 23 تستخدم تأخيرًا بسيطًا بين دورات الساعة لتحقيق نفس الهدف بتكلفة أقل."
        },
        {
          "question_ar": "هل يمكن اعتبار هذا التصميم (الشريحة 23) وسيلة لـ **إخفاء الفشل (Failure Masking)** كما في الشريحة 18؟",
          "hint_ar": "لا، هذا التصميم يكشف الخطأ فقط (Detection)، ولا يُصححه تلقائيًا. الإخفاء يتطلب تصحيحًا فوريًا دون ظهور تأثير."
        }
      ]
    }
  },
  {
    "slide_number": 24,
    "slide_title_ar": "التكرار الزمني - كشف الأعطال العابرة",
    "slide_title_en": "Time Redundancy - Transient Fault Detection",
    "general_summary_ar": "تُوضح هذه الشريحة آلية **التكرار الزمني** لكشف الأعطال العابرة (Transient Faults) من خلال إعادة تنفيذ نفس العملية الحسابية في أوقات مختلفة (T1، T2، ...، Tn)، ثم تخزين النتائج ومقارنتها. إذا اختلفت النتائج، يُصدر النظام **إشارة خطأ (Error Signal)**. يتطلب بعض الأجهزة الإضافية لكن بتكلفة أقل من التكرار المادي الكامل.",
    "details_and_text": [
      {
        "text_en": "In time redundancy, computations are repeated at different points in time and then compared. Some extra hardware is required.",
        "explanation_ar": "**في التكرار الزمني:** تُعاد العمليات الحسابية في أوقات مختلفة، ثم تُقارن النتائج. يتطلب بعض الأجهزة الإضافية (مثل المخازن والمقارن)، لكن أقل بكثير من تكرار الدائرة بالكامل."
      },
      {
        "text_en": "T1 → Data → Computation → Store Result",
        "explanation_ar": "**في الوقت T1:** تُدخل البيانات، تُنفّذ العملية، ثم تُخزن النتيجة."
      },
      {
        "text_en": "T2 → Data → Computation → Store Result",
        "explanation_ar": "**في الوقت T2:** تُعاد نفس العملية مع نفس البيانات، وتُخزن النتيجة الجديدة."
      },
      {
        "text_en": "Tn → Data → Computation → Store Result",
        "explanation_ar": "**في الوقت Tn:** يمكن تكرار العملية مرات إضافية لزيادة الدقة في الكشف."
      },
      {
        "text_en": "Compare → Error Signal",
        "explanation_ar": "**المقارنة:** تُقارن جميع النتائج المخزنة. إذا كان هناك اختلاف → يُصدر **إشارة خطأ (Error Signal)** تشير إلى حدوث عطل عابر."
      },
      {
        "text_en": "Mermaid Diagram",
        "explanation_ar": "**رسم تخطيطي بصيغة Mermaid:** يُظهر التدفق الزمني للعمليات المتكررة، تخزين النتائج، ثم المقارنة لإصدار إشارة الخطأ.",
        "mermaid_diagram": "graph TD\n    subgraph Time\n        T1[T1] --> C1[Computation] --> S1[Store Result]\n        T2[T2] --> C2[Computation] --> S2[Store Result]\n        Tn[Tn] --> C3[Computation] --> S3[Store Result]\n    end\n\n    S1 --> COMP[Compare]\n    S2 --> COMP\n    S3 --> COMP\n    COMP --> ERR[Error Signal]\n\n    style T1 fill:#a050f5,stroke:#232048,stroke-width:3px,rx:15,ry:15\n    style T2 fill:#a050f5,stroke:#232048,stroke-width:3px,rx:15,ry:15\n    style Tn fill:#a050f5,stroke:#232048,stroke-width:3px,rx:15,ry:15\n    style C1 fill:#7c3aed,stroke:#232048,stroke-width:3px,rx:15,ry:15\n    style C2 fill:#7c3aed,stroke:#232048,stroke-width:3px,rx:15,ry:15\n    style C3 fill:#7c3aed,stroke:#232048,stroke-width:3px,rx:15,ry:15\n    style S1 fill:#8b5cf6,stroke:#232048,stroke-width:3px,rx:15,ry:15\n    style S2 fill:#8b5cf6,stroke:#232048,stroke-width:3px,rx:15,ry:15\n    style S3 fill:#8b5cf6,stroke:#232048,stroke-width:3px,rx:15,ry:15\n    style COMP fill:#FFA500,stroke:#232048,stroke-width:4px,color:#000,rx:20,ry:20\n    style ERR fill:#FF4500,stroke:#232048,stroke-width:4px,color:#FFF,rx:20,ry:20"
      }
    ],
    "questions_en_ar": {
      "a_current_slide_qa": [
        {
          "type": "Multiple Choice",
          "question_en": "What is the main purpose of repeating computations at different time points (T1, T2, ..., Tn)?",
          "options": [
            "(a) To improve system speed",
            "(b) To detect transient faults by comparing results",
            "(c) To reduce hardware cost",
            "(d) To permanently fix errors"
          ],
          "answer_en": "(b) To detect transient faults by comparing results",
          "explanation_ar": "الهدف هو اكتشاف الأعطال العابرة التي تؤثر على تنفيذ واحد فقط، مما يؤدي إلى نتائج مختلفة عند المقارنة."
        },
        {
          "type": "Multiple Choice",
          "question_en": "What happens when the stored results from different time points are compared and found to be different?",
          "options": [
            "(a) The system ignores the difference",
            "(b) An Error Signal is generated",
            "(c) The computation is permanently halted",
            "(d) The inputs are changed"
          ],
          "answer_en": "(b) An Error Signal is generated",
          "explanation_ar": "المقارن يُصدر إشارة خطأ عند اكتشاف عدم تطابق، مما يشير إلى حدوث عطل عابر."
        },
        {
          "type": "Multiple Choice",
          "question_en": "Compared to hardware redundancy, what is the advantage of this time redundancy approach?",
          "options": [
            "(a) No extra hardware is needed",
            "(b) Less hardware overhead (only storage + comparator)",
            "(c) It can detect permanent faults",
            "(d) It has no performance penalty"
          ],
          "answer_en": "(b) Less hardware overhead (only storage + comparator)",
          "explanation_ar": "لا يتطلب تكرار الدائرة المنطقية، بل فقط وحدات تخزين ومقارن، مما يقلل التكلفة المادية."
        },
        {
          "type": "Multiple Choice",
          "question_en": "Can this method reliably detect permanent faults?",
          "options": [
            "(a) Yes, by repeating more than twice",
            "(b) No, because permanent faults affect all executions equally",
            "(c) Only if the fault occurs during storage",
            "(d) Yes, if the comparison logic is duplicated"
          ],
          "answer_en": "(b) No, because permanent faults affect all executions equally",
          "explanation_ar": "العطل الدائم يُفسد كل التنفيذات بنفس الطريقة، فتكون النتائج متطابقة (لكن خاطئة)، ولا يُكتشف."
        },
        {
          "type": "True/False",
          "question_en": "Time redundancy requires duplicating the entire combinational logic circuit.",
          "options": [
            "True",
            "False"
          ],
          "answer_en": "False",
          "explanation_ar": "يكفي تخزين النتائج ومقارنتها، دون الحاجة لتكرار الدائرة الحسابية."
        }
      ],
      "b_previous_slides": [
        {
          "question_ar": "ما الفرق بين النهج في الشريحة 23 (تأخير بين دورات الساعة) والشريحة 24 (إعادة تنفيذ في أوقات منفصلة T1، T2، ...، Tn)؟",
          "hint_ar": "الشريحة 23 تستخدم تأخيرًا صغيرًا ضمن الدورة، بينما الشريحة 24 تعيد التنفيذ الكامل في أوقات منفصلة، مما يزيد من المرونة والتغطية لكن بتكلفة زمنية أعلى."
        },
        {
          "question_ar": "هل يمكن دمج هذا النهج (الشريحة 24) مع **إخفاء الفشل (Failure Masking)** من الشريحة 18؟",
          "hint_ar": "نعم، إذا أُضيف تصويت بالأغلبية (مثل 3 نتائج: T1، T2، T3) واختيار النتيجة الأكثر تكرارًا، يتحول من كشف إلى إخفاء."
        }
      ]
    }
  },
  {
    "slide_number": 25,
    "slide_title_ar": "التكرار الزمني - كشف الأعطال الدائمة",
    "slide_title_en": "Time Redundancy - Permanent Fault Detection",
    "general_summary_ar": "تُقدّم هذه الشريحة تقنية متقدمة من **التكرار الزمني** لكشف **الأعطال الدائمة (Permanent Faults)** من خلال تنفيذ العملية مرتين باستخدام **ترميز مختلف للمدخلات** في التنفيذ الثاني. يتم اختيار دالة الترميز بحيث تُظهر أي عطل دائم في الأجهزة كاختلاف في النتائج بعد فك الترميز، مما يُمكّن من كشف العيوب الثابتة التي لا يمكن اكتشافها بالتكرار الزمني العادي.",
    "details_and_text": [
      {
        "text_en": "During first computation, the operands are used as presented.",
        "explanation_ar": "**في التنفيذ الأول:** تُستخدم المدخلات (Operands) كما هي، بدون أي تعديل أو ترميز."
      },
      {
        "text_en": "During second computation, the operands are encoded in some fashion.",
        "explanation_ar": "**في التنفيذ الثاني:** تُرمّز المدخلات باستخدام دالة ترميز محددة (مثل قلب البتات، أو إضافة قيمة، أو تحويل رياضي)."
      },
      {
        "text_en": "The selection of encoding function is made so as to allow faults in the hardware to be detected.",
        "explanation_ar": "**اختيار دالة الترميز:** تُختار الدالة بحيث يؤدي أي عطل دائم في الدائرة (مثل بوابة معطلة) إلى نتيجة مختلفة في التنفيذ الثاني حتى بعد فك الترميز، مما يكشف العطل."
      },
      {
        "text_en": "Mermaid Diagram",
        "explanation_ar": "**رسم تخطيطي بصيغة Mermaid:** يُظهر مسارين: تنفيذ عادي (أزرق داكن)، وتنفيذ مُرمّز (سماوي) مع فك ترميز ومقارنة نهائية لكشف الخطأ.",
        "mermaid_diagram": "graph TD\n    subgraph First_Computation\n        A1[Operands Original] --> B1[Computation]\n        B1 --> C1[Store Result 1]\n    end\n\n    subgraph Second_Computation\n        A2[Operands Encoded] --> B2[Computation]\n        B2 --> C2[Store Result 2 Encoded]\n        C2 --> D[Decode]\n        D --> E[Compare with Result 1]\n    end\n\n    C1 --> E\n    E --> F{Error?}\n\n    style A1 fill:#232048,stroke:#000\n    style A2 fill:#a050f5,stroke:#000\n    style F fill:#FF4500,stroke:#000,color:#FFF"
      }
    ],
    "questions_en_ar": {
      "a_current_slide_qa": [
        {
          "type": "Multiple Choice",
          "question_en": "Why is encoding used in the second computation for permanent fault detection?",
          "options": [
            "(a) To speed up the computation",
            "(b) To make permanent faults produce different results in the two executions",
            "(c) To reduce memory usage",
            "(d) To encrypt the data"
          ],
          "answer_en": "(b) To make permanent faults produce different results in the two executions",
          "explanation_ar": "العطل الدائم يؤثر بنفس الطريقة على المدخلات العادية، لكن عند الترميز يُغيّر تأثيره، فتظهر النتائج مختلفة بعد فك الترميز."
        },
        {
          "type": "Multiple Choice",
          "question_en": "What must happen after the second (encoded) computation to detect the fault?",
          "options": [
            "(a) The result is discarded",
            "(b) The result is decoded and compared with the first result",
            "(c) The operands are re-encoded",
            "(d) The hardware is reset"
          ],
          "answer_en": "(b) The result is decoded and compared with the first result",
          "explanation_ar": "يجب فك ترميز النتيجة الثانية ثم مقارنتها بالنتيجة الأولى. الاختلاف يشير إلى وجود عطل دائم."
        },
        {
          "type": "Multiple Choice",
          "question_en": "Which of the following is an example of an encoding function that could help detect stuck-at faults?",
          "options": [
            "(a) Multiplying all operands by 1",
            "(b) Inverting all bits (1's complement)",
            "(c) Using the same operands again",
            "(d) Adding zero to each operand"
          ],
          "answer_en": "(b) Inverting all bits (1's complement)",
          "explanation_ar": "قلب البتات يُغيّر تأثير العطل (مثلاً: stuck-at-0 سيُصبح stuck-at-1 في النسخة المقلوبة)، فيظهر الخطأ عند المقارنة."
        },
        {
          "type": "Multiple Choice",
          "question_en": "Can regular time redundancy (without encoding) detect permanent faults?",
          "options": [
            "(a) Yes, reliably",
            "(b) No, because both executions are affected identically",
            "(c) Only if repeated more than twice",
            "(d) Yes, if the clock is delayed"
          ],
          "answer_en": "(b) No, because both executions are affected identically",
          "explanation_ar": "بدون ترميز، العطل الدائم يُفسد كِلا التنفيذين بنفس الطريقة → نتائج متطابقة (خاطئة) → لا يُكتشف."
        },
        {
          "type": "True/False",
          "question_en": "The encoding function must be invertible to allow correct comparison.",
          "options": [
            "True",
            "False"
          ],
          "answer_en": "True",
          "explanation_ar": "يجب أن تكون دالة الترميز قابلة للعكس (invertible) حتى يمكن فك الترميز ومقارنة النتيجة بالأصلية بدقة."
        },
        {
          "type": "Definition",
          "question_en": "Explain briefly how this method overcomes the limitation of basic time redundancy.",
          "answer_en": "By using different data representations (encoding), a permanent hardware fault affects the two computations differently, causing mismatched results even after decoding.",
          "explanation_ar": "الترميز يُغيّر شكل البيانات، فالعطل الدائم الذي يُفسد '0' لن يُفسد '1' في النسخة المرمزة، فيظهر التناقض عند المقارنة."
        }
      ],
      "b_previous_slides": [
        {
          "question_ar": "كيف تختلف تقنية كشف الأعطال الدائمة في الشريحة 25 عن كشف الأعطال العابرة في الشريحة 24؟",
          "hint_ar": "الشريحة 24 تكرر بنفس البيانات (يكشف العابر فقط)، أما الشريحة 25 تُرمز البيانات في التنفيذ الثاني لتكشف الدائم."
        },
        {
          "question_ar": "هل يمكن تطبيق هذه الطريقة (الشريحة 25) مع **إخفاء الفشل (Failure Masking)** من الشريحة 18؟",
          "hint_ar": "نعم، إذا أُجري تنفيذ ثالث (مثلاً بترميز آخر) واستُخدم التصويت بالأغلبية على النتائج المفكوكة، يصبح النظام قادرًا على الإخفاء."
        }
      ]
    }
  },
  {
    "slide_number": 26,
    "slide_title_ar": "التكرار الزمني - كشف الأعطال الدائمة (مع الترميز)",
    "slide_title_en": "Time Redundancy - Permanent Fault Detection (with Encoding)",
    "general_summary_ar": "تُوضح هذه الشريحة آلية عملية لكشف **الأعطال الدائمة** باستخدام التكرار الزمني مع **ترميز المدخلات** في التنفيذ الثاني. يتم تنفيذ العملية مرة بالبيانات العادية (T1)، ومرة بالبيانات المُرمَّزة (Tn)، ثم فك الترميز ومقارنة النتائج. أي اختلاف يُشير إلى وجود عطل دائم في الأجهزة، مما يُمكّن من كشف ما لا يُكتشف بالتكرار الزمني العادي.",
    "details_and_text": [
      {
        "text_en": "T1: Data → Computation → Store Result",
        "explanation_ar": "**التنفيذ الأول (T1):** البيانات تُدخل كما هي، تُنفَّذ العملية، وتُخزن النتيجة الأولى."
      },
      {
        "text_en": "Tn: Data → Encode → Computation → Store Result → Decode",
        "explanation_ar": "**التنفيذ الثاني (Tn):** البيانات تُرمَّز أولاً، ثم تُنفَّذ العملية على النسخة المُرمَّزة، تُخزن النتيجة، ثم تُفكّ النتيجة لتعود إلى النطاق الأصلي."
      },
      {
        "text_en": "Compare → Error Signal",
        "explanation_ar": "**المقارنة:** تُقارن النتيجة الأولى (T1) مع النتيجة المفكوكة (من Tn). الاختلاف يُصدر **إشارة خطأ** تدل على عطل دائم."
      },
      {
        "text_en": "Why this detects permanent faults",
        "explanation_ar": "**لماذا ينجح هذا في كشف الأعطال الدائمة؟** العطل الدائم (مثل بوابة AND معطلة على 0) يؤثر بنفس الطريقة فقط إذا كانت البيانات متطابقة. لكن عند الترميز (مثل قلب البتات): `0` يصبح `1`، فالعطل الذي كان يُخرج `0` دائمًا يُخرج `1` دائمًا في التنفيذ الثاني. → النتيجة بعد فك الترميز **ستختلف** عن الأولى → يُكتشف العطل."
      },
      {
        "text_en": "Difference from regular time redundancy (Slide 24)",
        "explanation_ar": "**الفرق عن التكرار الزمني العادي (الشريحة 24):**\n| الطريقة | تكشف العابر؟ | تكشف الدائم؟ | السبب |\n|--------|--------------|--------------|------|\n| تكرار عادي | نعم | لا | العطل الدائم يُفسد التنفيذين بنفس الشكل → نتائج متطابقة (خاطئة). |\n| تكرار مع **ترميز** | نعم | نعم | الترميز يُغيّر شكل البيانات → يتغيّر تأثير العطل → نتائج مختلفة بعد فك الترميز. |"
      },
      {
        "text_en": "Important technical notes",
        "explanation_ar": "**ملاحظات تقنية مهمة:** \\n - دالة **الترميز وفك الترميز يجب أن تكون عكوسة (invertible)**.\\n- أمثلة على الترميز: قلب البتات (1’s complement)، إضافة قيمة ثابتة (+K، ثم -K)، تحويل رياضي.\\n- **التكلفة:** زيادة طفيفة في الوقت والأجهزة (وحدة ترميز + فك ترميز + مخزن)، لكن أقل بكثير من التكرار المادي الكامل."
      }
    ],
    "questions_en_ar": {
      "a_current_slide_qa": [
        {
          "type": "Multiple Choice",
          "question_en": "In the second computation (Tn), why is the data encoded before processing?",
          "options": [
            "(a) To reduce computation time",
            "(b) To make a permanent fault produce a different result after decoding",
            "(c) To compress the data",
            "(d) To protect against transient faults only"
          ],
          "answer_en": "(b) To make a permanent fault produce a different result after decoding",
          "explanation_ar": "الترميز يُغيّر تأثير العطل الدائم، فمثلاً: stuck-at-0 يُصبح stuck-at-1 في البيانات المقلوبة، فيظهر التناقض بعد فك الترميز."
        },
        {
          "type": "Multiple Choice",
          "question_en": "What is the purpose of the 'Decode' step after the second computation?",
          "options": [
            "(a) To re-encode the result",
            "(b) To convert the encoded result back to the original domain for comparison",
            "(c) To store the result permanently",
            "(d) To generate the error signal"
          ],
          "answer_en": "(b) To convert the encoded result back to the original domain for comparison",
          "explanation_ar": "يجب فك الترميز لتتمكن من مقارنة النتيجة الثانية بالأولى في نفس النطاق."
        },
        {
          "type": "Multiple Choice",
          "question_en": "If a permanent fault exists and the two final results (after decode) match, what does it mean?",
          "options": [
            "(a) The fault was transient",
            "(b) No fault occurred, or the encoding failed to expose it",
            "(c) The decode step failed",
            "(d) The comparison logic is faulty"
          ],
          "answer_en": "(b) No fault occurred, or the encoding failed to expose it",
          "explanation_ar": "إذا تطابقت النتائج بعد فك الترميز، فإما لا يوجد عطل، أو أن دالة الترميز لم تكن فعالة في كشف هذا النوع من العطل."
        },
        {
          "type": "True/False",
          "question_en": "This method can detect both transient and permanent faults simultaneously.",
          "options": [
            "True",
            "False"
          ],
          "answer_en": "True",
          "explanation_ar": "العطل العابر يُكتشف بالاختلاف العشوائي، والدائم بالاختلاف الناتج عن الترميز المختلف."
        },
        {
          "type": "Definition",
          "question_en": "Why does simple time redundancy (without encoding) fail to detect permanent faults, but this method succeeds?",
          "answer_en": "Because encoding changes the data pattern, causing the same hardware fault to corrupt the two computations differently, leading to mismatch after decoding.",
          "explanation_ar": "بدون ترميز: العطل يُفسد التنفيذين بنفس الشكل. مع الترميز: يتغير شكل البيانات، فيتغير تأثير العطل، فيظهر التناقض بعد فك الترميز."
        }
      ],
      "b_previous_slides": [
        {
          "question_ar": "ما التحسين الذي أضافته الشريحة 26 على الشريحة 25؟",
          "hint_ar": "الشريحة 25 وصفت الفكرة نظريًا، أما الشريحة 26 قدمت **مخططًا تنفيذيًا** يُظهر التدفق الزمني، الترميز، فك الترميز، والمقارنة."
        },
        {
          "question_ar": "هل يمكن تحويل هذا النظام من **كشف** إلى **إخفاء الفشل (Masking)**؟",
          "hint_ar": "نعم، بإجراء تنفيذ ثالث (بترميز مختلف) واستخدام **التصويت بالأغلبية** على النتائج المفكوكة الثلاث."
        }
      ]
    }
  },
  {
    "slide_number": 27,
    "slide_title_ar": "التكرار المعلوماتي",
    "slide_title_en": "Information Redundancy",
    "general_summary_ar": "تُعرّف هذه الشريحة **التكرار المعلوماتي** كإضافة بيانات زائدة (redundant information) إلى البيانات الأصلية لتحقيق **كشف الأعطال**، **إخفاء الفشل (fault masking)**، أو حتى **تحمّل الأعطال (fault tolerance)**. تُركز على **أكواد كشف وتصحيح الأخطاء (EDC codes)** المستخدمة أساسًا في البيئات الملوثة بالضوضاء (noisy environments).",
    "details_and_text": [
      {
        "text_en": "Definition: Information redundancy is the addition of redundant information to data to allow fault detection, fault masking or possibly fault tolerance.",
        "explanation_ar": "**تعريف التكرار المعلوماتي:** إضافة معلومات زائدة إلى البيانات الأصلية لتمكين:\n- **كشف الأعطال (fault detection)**\n- **إخفاء الفشل (fault masking)**\n- أو حتى **تحمّل الأعطال (fault tolerance)** في بعض الحالات المتقدمة."
      },
      {
        "text_en": "Error detecting and correcting codes (EDC codes): Encoding of information for transmission in noisy environments",
        "explanation_ar": "**أكواد كشف وتصحيح الأخطاء (EDC codes):** تقنيات ترميز تُستخدم لتشفير المعلومات أثناء النقل عبر قنوات تحتوي على **ضوضاء (noise)**، مما يُمكّن من اكتشاف الأخطاء الناتجة عن التشويش وتصحيحها تلقائيًا في بعض الأنواع."
      },
      {
        "text_en": "Why this detects permanent faults",
        "explanation_ar": "**لماذا ينجح التكرار المعلوماتي في كشف الأعطال الدائمة؟** لأن البيانات الزائدة تُنشئ قيودًا رياضية (مثل البتات التكافؤية أو مسافة هامينغ). أي تغيير غير مصرح به (سواء من عطل دائم أو ضوضاء) يُخلّ بهذه القيود، فيُكتشف."
      },
      {
        "text_en": "Difference from regular time redundancy (Slide 24)",
        "explanation_ar": "**الفرق عن التكرار الزمني العادي (الشريحة 24):**\n| الطريقة | الأساس | تكشف الدائم؟ | تكشف العابر؟ | التكلفة |\n|---------|--------|--------------|--------------|----------|\n| **التكرار الزمني** | إعادة تنفيذ | لا (إلا مع ترميز) | نعم | وقت إضافي |\n| **التكرار المعلوماتي** | بتات زائدة | نعم | نعم | حجم بيانات أكبر |"
      },
      {
        "text_en": "Important technical notes",
        "explanation_ar": "**ملاحظات تقنية مهمة:**\\n- يُستخدم في **الذاكرة، الاتصالات، الأقراص الصلبة، الشبكات**.\\n- أمثلة شائعة: **Parity Bit، Hamming Code، CRC، Reed-Solomon**.\\n- **القدرة على التصحيح** تعتمد على **عدد البتات الزائدة** و**مسافة الكود (Hamming Distance)**.\\n- لا يتطلب إعادة تنفيذ → لا يؤثر على الأداء الزمني."
      }
    ],
    "questions_en_ar": {
      "a_current_slide_qa": [
        {
          "type": "Multiple Choice",
          "question_en": "What is the primary purpose of adding redundant information in Information Redundancy?",
          "options": [
            "(a) To increase data speed",
            "(b) To allow fault detection and possibly correction",
            "(c) To reduce memory usage",
            "(d) To encrypt the data"
          ],
          "answer_en": "(b) To allow fault detection and possibly correction",
          "explanation_ar": "البيانات الزائدة تُمكّن النظام من اكتشاف الأخطاء (وأحيانًا تصحيحها) الناتجة عن الأعطال أو الضوضاء."
        },
        {
          "type": "Multiple Choice",
          "question_en": "In which type of environment are EDC codes most commonly used?",
          "options": [
            "(a) Completely noise-free channels",
            "(b) Noisy environments (e.g., wireless, storage)",
            "(c) High-speed CPU registers",
            "(d) Permanent hardware duplication"
          ],
          "answer_en": "(b) Noisy environments (e.g., wireless, storage)",
          "explanation_ar": "EDC تعني Error Detection and Correction، وتُستخدم أساسًا في القنوات التي تتعرض للتشويش مثل الاتصالات اللاسلكية أو التخزين."
        },
        {
          "type": "Multiple Choice",
          "question_en": "Which of the following is an example of Information Redundancy?",
          "options": [
            "(a) Recomputing the same operation twice",
            "(b) Adding a parity bit to a 7-bit data word",
            "(c) Using two identical processors",
            "(d) Delaying the clock signal"
          ],
          "answer_en": "(b) Adding a parity bit to a 7-bit data word",
          "explanation_ar": "البت التكافؤي هو مثال كلاسيكي على التكرار المعلوماتي: بت زائد يُضاف لحساب التكافؤ."
        },
        {
          "type": "Multiple Choice",
          "question_en": "Compared to Time Redundancy, what is the main advantage of Information Redundancy?",
          "options": [
            "(a) No impact on performance (no delay)",
            "(b) Can detect permanent faults without encoding",
            "(c) Requires no extra hardware",
            "(d) Always corrects multiple errors"
          ],
          "answer_en": "(a) No impact on performance (no delay)",
          "explanation_ar": "لا يتطلب إعادة تنفيذ → لا يُبطئ النظام، لكنه يزيد من حجم البيانات."
        },
        {
          "type": "True/False",
          "question_en": "Information Redundancy can achieve fault masking if the code supports error correction.",
          "options": [
            "True",
            "False"
          ],
          "answer_en": "True",
          "explanation_ar": "نعم، أكواد مثل Hamming أو SEC-DED تُصحح الأخطاء تلقائيًا → تُخفي تأثير العطل (masking)."
        },
        {
          "type": "Definition",
          "question_en": "Explain how Information Redundancy differs from Time Redundancy in fault handling.",
          "answer_en": "Information Redundancy adds extra bits to data for immediate detection/correction without re-execution. Time Redundancy repeats the computation in time, introducing delay but using less storage.",
          "explanation_ar": "التكرار المعلوماتي يُضيف بتات → كشف/تصحيح فوري دون تأخير. التكرار الزمني يُعيد التنفيذ → يؤخر الأداء لكنه لا يزيد حجم البيانات."
        }
      ],
      "b_previous_slides": [
        {
          "question_ar": "كيف يرتبط **التكرار المعلوماتي** (الشريحة 27) بمفهوم **إخفاء الفشل (Failure Masking)** من الشريحة 18؟",
          "hint_ar": "نعم، عندما تُستخدم أكواد **تصحيح الأخطاء** (مثل Hamming)، يتم تصحيح الخطأ تلقائيًا دون ظهور تأثيره → إخفاء كامل للفشل."
        },
        {
          "question_ar": "هل يمكن دمج التكرار المعلوماتي مع التكرار الزمني (مثل الشريحة 26)؟",
          "hint_ar": "نعم، في الأنظمة عالية الموثوقية (مثل الفضاء)، يُستخدم **التكرار المعلوماتي** لحماية البيانات، و**التكرار الزمني مع الترميز** لحماية الحسابات."
        }
      ]
    }
  },
  {
    "slide_number": 28,
    "slide_title_ar": "التكرار المعلوماتي - نموذج الإرسال والاستقبال",
    "slide_title_en": "Information Redundancy - Transmission Model",
    "general_summary_ar": "تُظهر هذه الشريحة تطبيقًا عمليًا للتكرار المعلوماتي في نظام اتصال. يُرسل المرسل البيانات مع بيانات تكرار، ويتحقق المستقبل من صحتها بإعادة حساب التكرار. إذا تطابقت النتيجة → تُقبل البيانات، وإلا → تُرفض. يُستخدم لكشف الأخطاء الناتجة عن الضوضاء أو الأعطال أثناء النقل عبر الوسط.",
    "details_and_text": [
      {
        "text_en": "Sender node: Data + redundancy → Medium",
        "explanation_ar": "**المرسل:** يُرسل البيانات الأصلية (مثل: 10100000000101010) مع **بيانات التكرار** (مثل: 1011101) عبر الوسط."
      },
      {
        "text_en": "Receiver node: Received (Data & redundancy) → Check OK? → Yes/No",
        "explanation_ar": "**المستقبل:** يستقبل الرسالة الكاملة، يُعيد حساب التكرار من البيانات، ثم يُقارن. إذا تطابقت → **OK**، وإلا → **رفض البيانات**."
      },
      {
        "text_en": "Example: 10100000000101010 1011101",
        "explanation_ar": "**مثال عملي:** البيانات: `10100000000101010`، التكرار: `1011101` → إجمالي 23 بت. أي تغيير في أي بت سيُكتشف عند المقارنة."
      },
      {
        "text_en": "Why this detects errors during transmission",
        "explanation_ar": "**لماذا يكشف الأخطاء أثناء النقل؟** لأن أي تغيير في البتات (بسبب الضوضاء أو عطل) يُغيّر قيمة التكرار المحسوبة، فيظهر عدم تطابق."
      },
      {
        "text_en": "Difference from Time Redundancy (Slide 24)",
        "explanation_ar": "**الفرق عن التكرار الزمني (الشريحة 24):**\n| الطريقة | يحتاج إعادة إرسال؟ | يكشف الأخطاء أثناء النقل؟ | التأثير على الأداء |\n|---------|------------------|--------------------------|------------------|\n| **التكرار الزمني** | نعم | لا | تأخير كبير |\n| **التكرار المعلوماتي** | لا | نعم | لا تأخير، حجم أكبر |"
      },
      {
        "text_en": "Important technical notes",
        "explanation_ar": "**ملاحظات تقنية مهمة:**\\n- هذا النموذج يكشف الأخطاء فقط (Detection)، وليس تصحيحها.\\n- للتصحيح → استخدم أكواد مثل **Hamming أو Reed-Solomon**.\\n- شائع في: **Ethernet، Wi-Fi، USB، ECC Memory**.\\n- التكلفة: زيادة في **حجم البيانات**، لا تأخير زمني."
      }
    ],
    "questions_en_ar": {
      "a_current_slide_qa": [
        {
          "type": "Multiple Choice",
          "question_en": "What happens at the receiver if the recalculated redundancy does NOT match the received redundancy?",
          "options": [
            "(a) The data is accepted anyway",
            "(b) The data is rejected",
            "(c) The sender is reset",
            "(d) The medium is repaired"
          ],
          "answer_en": "(b) The data is rejected",
          "explanation_ar": "عدم التطابق يعني حدوث خطأ أثناء النقل → تُرفض البيانات."
        },
        {
          "type": "Multiple Choice",
          "question_en": "What is the role of the redundancy bits in this model?",
          "options": [
            "(a) To speed up transmission",
            "(b) To enable error detection at the receiver",
            "(c) To encrypt the data",
            "(d) To reduce the data size"
          ],
          "answer_en": "(b) To enable error detection at the receiver",
          "explanation_ar": "بتات التكرار تُمكّن المستقبل من التحقق من سلامة البيانات."
        },
        {
          "type": "Multiple Choice",
          "question_en": "In this diagram, can the receiver correct the error automatically?",
          "options": [
            "(a) Yes, using the redundancy bits",
            "(b) No, it can only detect and reject",
            "(c) Yes, by retransmitting",
            "(d) Only if the medium is clean"
          ],
          "answer_en": "(b) No, it can only detect and reject",
          "explanation_ar": "النموذج يُظهر **كشف فقط (Detection)**، وليس تصحيح. التصحيح يتطلب أكواد أقوى مثل Hamming."
        },
        {
          "type": "Multiple Choice",
          "question_en": "Which real-world protocol uses a similar mechanism?",
          "options": [
            "(a) TCP handshake",
            "(b) Ethernet with CRC-32",
            "(c) HTTP request",
            "(d) DNS query"
          ],
          "answer_en": "(b) Ethernet with CRC-32",
          "explanation_ar": "Ethernet يُضيف CRC-32 في نهاية الإطار للتحقق من سلامة البيانات أثناء النقل."
        },
        {
          "type": "True/False",
          "question_en": "This information redundancy model introduces performance delay.",
          "options": [
            "True",
            "False"
          ],
          "answer_en": "False",
          "explanation_ar": "لا يوجد تأخير زمني، فقط زيادة في حجم البيانات."
        }
      ],
      "b_previous_slides": [
        {
          "question_ar": "كيف يرتبط هذا النموذج (الشريحة 28) بتعريف التكرار المعلوماتي في الشريحة 27؟",
          "hint_ar": "الشريحة 27 عرّفت المفهوم، والشريحة 28 تُظهر تطبيقًا عمليًا في الاتصال: إضافة تكرار → كشف الأخطاء أثناء النقل."
        },
        {
          "question_ar": "هل يمكن تحويل هذا النظام من **كشف** إلى **إخفاء الفشل (Masking)**؟",
          "hint_ar": "نعم، باستخدام أكواد تصحيح الأخطاء (مثل Hamming) بدلاً من كشف فقط → يُصحح الخطأ تلقائيًا دون رفض البيانات."
        }
      ]
    }
  },
  {
    "slide_number": 29,
    "slide_title_ar": "التكرار المعلوماتي - تطبيق على المخرجات",
    "slide_title_en": "Information Redundancy - Output Encoding",
    "general_summary_ar": "تُركّز هذه الشريحة على استخدام **التكرار المعلوماتي** في **ترميز المخرجات (outputs)** من وحدة ما باستخدام أكواد كشف أو تصحيح الأخطاء. الهدف هو تقليل التكرار المطلوب مع الحفاظ على كشف الأعطال، مع تسليط الضوء على المزايا (أقل أجهزة) والعيوب (تعقيد التصميم).",
    "details_and_text": [
      {
        "text_en": "Encode outputs with error detecting or correcting code",
        "explanation_ar": "**ترميز المخرجات بكود كشف أو تصحيح الأخطاء:** يتم إضافة بيانات تكرارية إلى مخرجات الوحدة (مثل معالج أو دائرة منطقية) لتتمكن من كشف أو تصحيح الأخطاء الناتجة عن عطل داخلي."
      },
      {
        "text_en": "Code selected to minimize redundancy for class of faults",
        "explanation_ar": "**اختيار الكود لتقليل التكرار حسب نوع الأعطال:** يُختار نوع الكود (مثل Parity، Hamming، CRC) بحيث يُغطي الفئة المطلوبة من الأعطال بأقل عدد ممكن من البتات الزائدة."
      },
      {
        "text_en": "Advantage: Less hardware to generate redundant information than replicating module",
        "explanation_ar": "**الميزة:** أقل أجهزة مقارنة بتكرار الوحدة بالكامل. بدلاً من نسخ الدائرة كاملة (Hardware Redundancy)، يُضاف فقط مولّد كود بسيط (مثل XOR gates لـ Parity)."
      },
      {
        "text_en": "Drawback: Added complexity in design",
        "explanation_ar": "**العيب:** زيادة في تعقيد التصميم. يتطلب تصميم دائرة ترميز/فك ترميز، وفهمًا لأنواع الأعطال المستهدفة، واختبار الكود."
      },
      {
        "text_en": "Why this detects permanent faults",
        "explanation_ar": "**لماذا يكشف الأعطال الدائمة؟** العطل الدائم في الوحدة سيُغيّر المخرجات، مما يُخلّ بقواعد الكود (مثل التكافؤ أو مسافة هامينغ)، فيُكتشف عند التحقق."
      },
      {
        "text_en": "Difference from Time Redundancy (Slide 24)",
        "explanation_ar": "**الفرق عن التكرار الزمني (الشريحة 24):**\n| الطريقة | الأساس | التكلفة | التأثير على الأداء |\n|---------|--------|----------|-------------------|\n| **التكرار الزمني** | إعادة تنفيذ | وقت إضافي | تأخير كبير |\n| **التكرار المعلوماتي** | بتات زائدة | أجهزة إضافية بسيطة | لا تأخير |"
      },
      {
        "text_en": "Important technical notes",
        "explanation_ar": "**ملاحظات تقنية مهمة:**\\n- يُستخدم في **المعالجات، الذاكرة (ECC)، الاتصالات الداخلية**.\\n- مثال: **Parity على خطوط البيانات**، **Hamming في الذاكرة**.\\n- الكود يُصمم حسب **نموذج العطل (Fault Model)**: stuck-at، transient، multiple-bit.\\n- يمكن دمجه مع **التكرار المادي** لتحقيق **إخفاء الفشل**."
      }
    ],
    "questions_en_ar": {
      "a_current_slide_qa": [
        {
          "type": "Multiple Choice",
          "question_en": "What is the main goal when selecting an error-detecting code for outputs?",
          "options": [
            "(a) To maximize the number of redundancy bits",
            "(b) To minimize redundancy while covering the target fault class",
            "(c) To eliminate all hardware",
            "(d) To slow down the system"
          ],
          "answer_en": "(b) To minimize redundancy while covering the target fault class",
          "explanation_ar": "يُختار الكود ليكون فعالًا بأقل بتات ممكنة مع ضمان كشف الأعطال المطلوبة."
        },
        {
          "type": "Multiple Choice",
          "question_en": "Compared to hardware replication, what is the key advantage of encoding outputs?",
          "options": [
            "(a) No design complexity",
            "(b) Less hardware overhead",
            "(c) Guaranteed fault masking",
            "(d) Zero latency"
          ],
          "answer_en": "(b) Less hardware overhead",
          "explanation_ar": "بدلاً من تكرار الوحدة كاملة، يُضاف فقط مولّد كود بسيط (مثل دائرة XOR)."
        },
        {
          "type": "Multiple Choice",
          "question_en": "What is the primary drawback mentioned for this approach?",
          "options": [
            "(a) High performance penalty",
            "(b) Added complexity in design",
            "(c) Inability to detect faults",
            "(d) Large data size"
          ],
          "answer_en": "(b) Added complexity in design",
          "explanation_ar": "يتطلب تصميم دقيق للترميز، اختيار الكود المناسب، وآلية التحقق."
        },
        {
          "type": "Multiple Choice",
          "question_en": "Which of the following is an example of encoding outputs with minimal redundancy?",
          "options": [
            "(a) Duplicating the entire ALU",
            "(b) Adding a parity bit to a data bus",
            "(c) Recomputing the result twice",
            "(d) Using two separate memory modules"
          ],
          "answer_en": "(b) Adding a parity bit to a data bus",
          "explanation_ar": "بت واحد فقط يُضاف لكشف خطأ في أي بت من البيانات."
        },
        {
          "type": "True/False",
          "question_en": "This method can achieve fault masking if a correcting code is used.",
          "options": [
            "True",
            "False"
          ],
          "answer_en": "True",
          "explanation_ar": "نعم، إذا استُخدم كود تصحيح (مثل Hamming)، يُمكن تصحيح الخطأ تلقائيًا → إخفاء الفشل."
        },
        {
          "type": "Definition",
          "question_en": "Explain why encoding outputs uses less hardware than module replication.",
          "answer_en": "Instead of duplicating the entire functional module (which could be large), only a small encoder circuit (e.g., XOR gates for parity) is added to generate redundancy.",
          "explanation_ar": "تكرار الوحدة يعني نسخ كل البوابات، بينما ترميز المخرجات يحتاج فقط دائرة صغيرة لتوليد الكود."
        }
      ],
      "b_previous_slides": [
        {
          "question_ar": "كيف يرتبط هذا النهج (الشريحة 29) بنموذج الإرسال في الشريحة 28؟",
          "hint_ar": "الشريحة 28 طبّقت التكرار على البيانات أثناء النقل، أما الشريحة 29 تُطبّقه على **مخرجات وحدة داخلية** (مثل معالج أو دائرة) لحمايتها من الأعطال الداخلية."
        },
        {
          "question_ar": "هل يمكن استخدام هذا الأسلوب مع **التكرار الزمني (الشريحة 26)** لتحسين الموثوقية؟",
          "hint_ar": "نعم، يُستخدم **ترميز المخرجات** لحماية البيانات، و**التكرار الزمني مع الترميز** لحماية العمليات الحسابية → نظام هجين عالي الموثوقية."
        }
      ]
    }
  },
  {
    "slide_number": 30,
    "slide_title_ar": "نظرية الترميز",
    "slide_title_en": "Coding Theory",
    "general_summary_ar": "تُعرّف هذه الشريحة **نظرية الترميز** كاستخدام بتات أكثر من اللازم لتمثيل البيانات، بهدف كشف الأخطاء الناتجة عن انقلاب البتات. تُركّز على **أكواد كشف الأخطاء** المختلفة التي تُغطي فئات مختلفة من الأعطال بكميات متفاوتة من التكرار، مع مراعاة سهولة الترميز وفك الترميز.",
    "details_and_text": [
      {
        "text_en": "Coding: Using more bits than necessary to represent data",
        "explanation_ar": "**الترميز:** استخدام عدد أكبر من البتات مما هو مطلوب لتمثيل البيانات الأصلية، بهدف إضافة تكرار معلوماتي."
      },
      {
        "text_en": "Provides way to detect errors – Errors occur when bits get flipped",
        "explanation_ar": "**كشف الأخطاء:** يحدث الخطأ عندما ينقلب بت من 0 إلى 1 أو العكس (bit flip)، والكود يكشف هذا الانقلاب."
      },
      {
        "text_en": "Error Detecting Codes: Many types, detect different classes of errors",
        "explanation_ar": "**أكواد كشف الأخطاء:** أنواع متعددة (Parity، CRC، Checksum)، كل نوع يكشف فئة معينة من الأخطاء (خطأ واحد، أخطاء متتالية...)."
      },
      {
        "text_en": "Use different amounts of redundancy",
        "explanation_ar": "**كمية التكرار:** تختلف حسب الكود: بت واحد (Parity)، أو 32 بت (CRC-32)."
      },
      {
        "text_en": "Ease of encoding and decoding data varies",
        "explanation_ar": "**سهولة الترميز/فك الترميز تختلف:** حسب نوع الكود – أكواد بسيطة (Parity) سهلة وسريعة، أكواد معقدة (Reed-Solomon) تحتاج معالجة أكثر."
      },
      {
        "text_en": "Example: Parity Bit (Before & After bit flip)",
        "explanation_ar": "**مثال عملي (Parity):**\\n- البيانات: `1011` → مع Parity (زوجي): `10111`\\n- أثناء النقل: انقلاب → `10011`\\n- في المستقبل: مجموع الـ1 = 3 (فردي) → **خطأ مكتشف!**"
      },
      {
        "text_en": "Why this detects permanent faults",
        "explanation_ar": "**لماذا يكشف الأعطال الدائمة؟** العطل الدائم في الدائرة يُسبب انقلابات منتظمة في المخرجات → تُخلّ بقواعد الكود → يُكتشف."
      },
      {
        "text_en": "Difference from Time Redundancy (Slide 24)",
        "explanation_ar": "**الفرق عن التكرار الزمني (الشريحة 24):**\\n| الطريقة | الأساس | التكلفة | التأثير على الأداء |\\n|---------|--------|----------|-------------------|\\n| **التكرار الزمني** | إعادة تنفيذ | وقت إضافي | تأخير كبير |\\n| **الترميز** | بتات زائدة | حجم أكبر | لا تأخير |"
      },
      {
        "text_en": "Important technical notes",
        "explanation_ar": "**ملاحظات تقنية مهمة:**\\n- الترميز **يكشف** الخطأ، لا يمنعه.\\n- للتصحيح → أكواد مثل **Hamming، Reed-Solomon**.\\n- يُستخدم في: **ECC RAM، HDD، Wi-Fi، 5G، الفضاء**.\\n- اختيار الكود يعتمد على: نوع الخطأ، التكلفة، الأداء."
      }
    ],
    "questions_en_ar": {
      "a_current_slide_qa": [
        {
          "type": "Multiple Choice",
          "question_en": "What is the main reason for using more bits than necessary in coding?",
          "options": [
            "(a) To increase speed",
            "(b) To detect bit flips (errors)",
            "(c) To reduce hardware",
            "(d) To encrypt data"
          ],
          "answer_en": "(b) To detect bit flips (errors)",
          "explanation_ar": "البتات الزائدة تُمكّن من كشف الانقلابات في البتات أثناء النقل أو المعالجة."
        },
        {
          "type": "Multiple Choice",
          "question_en": "In the parity bit example, if data `1011` is sent as `10111` and received as `10011`, what happens?",
          "options": [
            "(a) Accepted as correct",
            "(b) Error detected (odd parity)",
            "(c) Error corrected automatically",
            "(d) Data is retransmitted"
          ],
          "answer_en": "(b) Error detected (odd parity)",
          "explanation_ar": "مجموع الـ1 = 3 (فردي)، لكن الكود يتطلب زوجي → خطأ مكتشف."
        },
        {
          "type": "Multiple Choice",
          "question_en": "Which factor is NOT considered when choosing an error detecting code?",
          "options": [
            "(a) Type of errors to detect",
            "(b) Amount of redundancy",
            "(c) Ease of encoding/decoding",
            "(d) Color of the data bus"
          ],
          "answer_en": "(d) Color of the data bus",
          "explanation_ar": "لون الناقل لا يؤثر – العوامل التقنية فقط هي المعيار."
        },
        {
          "type": "True/False",
          "question_en": "All error detecting codes can correct errors.",
          "options": [
            "True",
            "False"
          ],
          "answer_en": "False",
          "explanation_ar": "أكواد **الكشف** تكتشف فقط. التصحيح يتطلب أكواد **تصحيح** (مثل Hamming)."
        },
        {
          "type": "Definition",
          "question_en": "Explain with an example how a bit flip is detected using parity.",
          "answer_en": "Data: 1011 → Even parity: 10111. If bit 3 flips → 10011. Recalculated parity = odd → mismatch → error detected.",
          "explanation_ar": "البيانات: `1011` → مع تكافؤ زوجي: `10111`. انقلاب البت الثالث → `10011` → مجموع فردي → خطأ مكتشف."
        }
      ],
      "b_previous_slides": [
        {
          "question_ar": "ما العلاقة بين **نظرية الترميز** (الشريحة 30) و**ترميز المخرجات** في الشريحة 29؟",
          "hint_ar": "الشريحة 29 طبّقت المبدأ، والشريحة 30 تُعطي الأساس النظري: كيف تُصمم الأكواد لتكون فعالة وسهلة."
        },
        {
          "question_ar": "هل يمكن استخدام أكواد الترميز مع **التكرار الزمني**؟",
          "hint_ar": "نعم، في الأنظمة عالية الأمان: **ترميز لكشف الأخطاء** + **تكرار زمني للتحقق** → موثوقية مزدوجة."
        }
      ]
    }
  },
  {
    "slide_number": 31,
    "slide_title_ar": "كود الكتل",
    "slide_title_en": "Block Code",
    "general_summary_ar": "تُوضح هذه الشريحة مبدأ **كود الكتل** في كشف الأخطاء: يُقسم الفضاء الكلي إلى **كلمات صالحة (Codewords)** و**غير صالحة**. يُكتشف الخطأ إذا تحولت الكلمة الصالحة إلى غير صالحة، لكن **لا يُكتشف** إذا تحولت إلى كلمة صالحة أخرى (بسبب مسافة هامينغ صغيرة).",
    "details_and_text": [
      {
        "text_en": "To detect errors, some redundancy needed",
        "explanation_ar": "**التكرار ضروري لكشف الأخطاء:** بدون تكرار، كل كلمة ممكنة تُعتبر صالحة → لا يُمكن تمييز الخطأ."
      },
      {
        "text_en": "Space of distinct 2n blocks partitioned into codewords and non-codewords",
        "explanation_ar": "**تقسيم الفضاء:** من 2ⁿ كلمة ممكنة، يُختار عدد أقل كـ **كلمات صالحة**، والباقي **غير صالح**."
      },
      {
        "text_en": "Can detect errors that cause codeword to become non-codeword",
        "explanation_ar": "**يكشف الأخطاء المكتشفة:** إذا تحولت كلمة صالحة إلى غير صالحة → خطأ مكتشف."
      },
      {
        "text_en": "Cannot detect errors that cause codeword to become another codeword",
        "explanation_ar": "**لا يكشف الأخطاء غير المكتشفة:** إذا تحولت كلمة صالحة إلى أخرى صالحة → يُفسَّر كبيانات صحيحة (خطأ مخفي)."
      },
      {
        "text_en": "Example: Simple (4,3) Parity Code",
        "explanation_ar": "**مثال (4,3):**\\n- كلمة مُرسلة: `0110` → انقلاب بت: `0100` (غير صالح) → **مكتشف**\\n- انقلاب بتّين: `0110` → `1111` (صالح) → **غير مكتشف**"
      },
      {
        "text_en": "Why this detects permanent faults",
        "explanation_ar": "**لماذا يكشف الأعطال الدائمة؟** العطل الدائم يُسبب تغييرًا منتظمًا في المخرجات → يُحوّل الكلمة الصالحة إلى غير صالحة في معظم الحالات."
      },
      {
        "text_en": "Difference from Time Redundancy (Slide 24)",
        "explanation_ar": "**الفرق عن التكرار الزمني:**\n| الطريقة | كيف تكشف؟ | يكشف خطأين؟ | التكلفة |\n|---------|-----------|-------------|--------|\n| زمني | مقارنة تنفيذين | نعم | تأخير |\n| كتل | صحة الكلمة | فقط إذا d_min > 2 | حجم أكبر |"
      },
      {
        "text_en": "Important technical notes",
        "explanation_ar": "**ملاحظات تقنية مهمة:**\\n- **مسافة هامينغ (d_min)** تحدد قدرة الكشف.\\n- كود هامينغ: d_min = 3 → يكشف خطأين، يُصحح واحد.\\n- **لا يوجد كود يكشف كل الأخطاء** – دائمًا احتمال خطأ مخفي.\\n- يُستخدم في: ECC، الاتصالات، التخزين."
      }
    ],
    "questions_en_ar": {
      "a_current_slide_qa": [
        {
          "type": "Multiple Choice",
          "question_en": "In a block code, when is an error guaranteed to be detected?",
          "options": [
            "(a) When any bit flips",
            "(b) When a codeword becomes a non-codeword",
            "(c) When two codewords are identical",
            "(d) When redundancy is zero"
          ],
          "answer_en": "(b) When a codeword becomes a non-codeword",
          "explanation_ar": "فقط إذا خرجت الكلمة عن مجموعة الكلمات الصالحة → يُكتشف الخطأ."
        },
        {
          "type": "Multiple Choice",
          "question_en": "Why might a 2-bit error go undetected in a simple parity code?",
          "options": [
            "(a) Because parity bit is missing",
            "(b) Because it changes one codeword to another valid codeword",
            "(c) Because the receiver ignores errors",
            "(d) Because the medium is perfect"
          ],
          "answer_en": "(b) Because it changes one codeword to another valid codeword",
          "explanation_ar": "انقلاب بتّين قد يُحوّل كلمة صالحة إلى أخرى صالحة → خطأ مخفي."
        },
        {
          "type": "Multiple Choice",
          "question_en": "What is the minimum Hamming distance required to detect 2 errors?",
          "options": [
            "(a) 1",
            "(b) 2",
            "(c) 3",
            "(d) 4"
          ],
          "answer_en": "(c) 3",
          "explanation_ar": "d_min ≥ t + 1 → لكشف خطأين: d_min ≥ 3"
        },
        {
          "type": "True/False",
          "question_en": "A block code with d_min = 3 can correct 1 error.",
          "options": [
            "True",
            "False"
          ],
          "answer_en": "True",
          "explanation_ar": "نعم، للتصحيح: d_min ≥ 2t + 1 → t = 1 → d_min ≥ 3"
        },
        {
          "type": "Definition",
          "question_en": "Explain with an example why some errors are undetectable in block codes.",
          "answer_en": "In a (4,3) parity code, sending `0110` (for data 011). If two bits flip to `1111` (valid for data 111), the receiver accepts it as correct → error undetected.",
          "explanation_ar": "مثال: `0110` → `1111` (كلاهما صالح) → المستقبل يقبل `111` بدل `011` → خطأ غير مكتشف."
        }
      ],
      "b_previous_slides": [
        {
          "question_ar": "كيف يرتبط **كود الكتل** (الشريحة 31) بـ **كود هامينغ** الذي شرحناه؟",
          "hint_ar": "كود هامينغ هو نوع من **كود الكتل** مع d_min = 3 → يكشف خطأين ويُصحح واحد."
        },
        {
          "question_ar": "هل يمكن دمج كود الكتل مع **التكرار الزمني**؟",
          "hint_ar": "نعم، في الأنظمة عالية الأمان: **كود كتل لكشف الأخطاء في البيانات** + **تكرار زمني للتحقق من العمليات**."
        }
      ]
    }
  },
  {
    "slide_number": 32,
    "slide_title_ar": "تعريف الكود",
    "slide_title_en": "Code",
    "general_summary_ar": "تُعرّف هذه الشريحة **الكود** كمجموعة من التسلسلات (n-tuples) التي تتبع قواعد محددة. تُركّز على **الكود الثنائي** و**كود BCD** الذي يُمثّل كل رقم عشري بـ 4 بتات (من 0000 إلى 1001). يُستخدم BCD لسهولة العرض، ويكشف بعض الأخطاء لكنه ليس مُصممًا للتصحيح.",
    "details_and_text": [
      {
        "text_en": "Code of length n is a set of n-tuples satisfying some well-defined set of rules",
        "explanation_ar": "**تعريف الكود:** مجموعة من التسلسلات بطول n (مثل 4 بتات) تُلبي قواعد واضحة تحدد ما هو صالح."
      },
      {
        "text_en": "Binary code uses only 0 and 1 symbols",
        "explanation_ar": "**الكود الثنائي:** يستخدم رمزين فقط: 0 و 1 → أساس كل الأكواد الرقمية."
      },
      {
        "text_en": "binary coded decimal (BCD) code uses 4 bits for each decimal digit",
        "explanation_ar": "**كود BCD:** كل رقم عشري (0–9) يُمثّل بـ 4 بتات، من `0000` إلى `1001`."
      },
      {
        "text_en": "0000 for 0, 0001 for 1, ..., 1001 for 9",
        "explanation_ar": "**جدول BCD:**\\n0 → `0000`\\n1 → `0001`\\n...\\n9 → `1001`"
      },
      {
        "text_en": "Example: Number 925 in BCD",
        "explanation_ar": "**مثال:** الرقم 925 → `1001 0010 0101`"
      },
      {
        "text_en": "Error detection in BCD",
        "explanation_ar": "**كشف الأخطاء في BCD:**\\n- `0010` (2) → `0011` (غير صالح) → **مكتشف**\\n- `0010` → `1001` (9) → **غير مكتشف**"
      },
      {
        "text_en": "Why this detects permanent faults",
        "explanation_ar": "**لماذا يكشف الأعطال الدائمة؟** العطل في دائرة BCD قد يُخرج كلمة غير صالحة (مثل `1010`) → يُكتشف كخطأ."
      },
      {
        "text_en": "Difference from Time Redundancy (Slide 24)",
        "explanation_ar": "**الفرق عن التكرار الزمني:**\n| الطريقة | الهدف | يكشف الأخطاء؟ | التكلفة |\n|---------|-------|---------------|--------|\n| زمني | كشف أعطال | نعم | تأخير |\n| BCD | تمثيل أرقام | جزئيًا | حجم أكبر |"
      },
      {
        "text_en": "Important technical notes",
        "explanation_ar": "**ملاحظات تقنية مهمة:**\\n- BCD **ليس كود تصحيح** – مجرد تمثيل.\\n- يكشف بعض الأخطاء (مثل `1010`) لكنه يُخطئ في أخرى.\\n- يُستخدم في: **العدادات، الشاشات، الآلات الحاسبة**.\\n- لتحسين الكشف: أضف **بت تكافؤ** أو **هامينغ**."
      }
    ],
    "questions_en_ar": {
      "a_current_slide_qa": [
        {
          "type": "Multiple Choice",
          "question_en": "How many valid codewords are there in BCD?",
          "options": [
            "(a) 16",
            "(b) 10",
            "(c) 4",
            "(d) 2"
          ],
          "answer_en": "(b) 10",
          "explanation_ar": "فقط الأرقام من 0 إلى 9 → 10 كلمات صالحة من 16 ممكنة."
        },
        {
          "type": "Multiple Choice",
          "question_en": "What is the BCD representation of the decimal number 7?",
          "options": [
            "(a) 0111",
            "(b) 0110",
            "(c) 1110",
            "(d) 1000"
          ],
          "answer_en": "(a) 0111",
          "explanation_ar": "7 → `0111` في BCD."
        },
        {
          "type": "Multiple Choice",
          "question_en": "If BCD code `0010` is received as `1010`, what happens?",
          "options": [
            "(a) Accepted as 2",
            "(b) Error detected (invalid codeword)",
            "(c) Corrected to 0010",
            "(d) Ignored"
          ],
          "answer_en": "(b) Error detected (invalid codeword)",
          "explanation_ar": "`1010` ليس رقمًا من 0–9 → خطأ مكتشف."
        },
        {
          "type": "Multiple Choice",
          "question_en": "Why is BCD used in digital clocks?",
          "options": [
            "(a) To correct errors",
            "(b) For easy human-readable display",
            "(c) To reduce power",
            "(d) To increase speed"
          ],
          "answer_en": "(b) For easy human-readable display",
          "explanation_ar": "كل 4 بتات = رقم عشري → سهل التحويل إلى شاشة 7-segment."
        },
        {
          "type": "True/False",
          "question_en": "BCD can detect all single-bit errors.",
          "options": [
            "True",
            "False"
          ],
          "answer_en": "False",
          "explanation_ar": "بعض انقلابات البت تُحوّل كلمة صالحة إلى أخرى (مثل `0010` → `1001`)."
        }
      ],
      "b_previous_slides": [
        {
          "question_ar": "كيف يرتبط **BCD** (الشريحة 32) بـ **كود الكتل** في الشريحة 31؟",
          "hint_ar": "BCD هو نوع من **كود الكتل** بطول 4: 10 كلمات صالحة من 16، ويكشف بعض الأخطاء."
        },
        {
          "question_ar": "هل يمكن تحسين BCD ليكشف كل الأخطاء؟",
          "hint_ar": "نعم، بإضافة **بت تكافؤ** أو استخدام **كود هامينغ موسع**."
        }
      ]
    }
  },
  {
    "slide_number": 33,
    "slide_title_ar": "كلمة الكود",
    "slide_title_en": "Code Word",
    "general_summary_ar": "تُعرّف هذه الشريحة **كلمة الكود (Codeword)** كتسلسل رمزي يُمثّل بيانات وفق قواعد الكود، و**Word** كأي تسلسل لا يتبع القواعد. الكلمات الصالحة هي مجموعة فرعية من 2ⁿ تسلسل ثنائي لتمكين كشف/تصحيح الأخطاء. الهدف: تمييز الأخطاء عند الخروج عن المجموعة الصالحة.",
    "details_and_text": [
      {
        "text_en": "A code word is a collection of symbols used to represent a particular piece of data based on specified code.",
        "explanation_ar": "**كلمة الكود:** مجموعة من الرموز (مثل 1001) تُمثّل بيانات (مثل الرقم 9) وفق قواعد الكود المحدد."
      },
      {
        "text_en": "A word is an n-tuple not satisfying the rules of the code.",
        "explanation_ar": "**Word (غير كود):** أي تسلسل من n بتات لا يتبع قواعد الكود (مثل 1010 في BCD)."
      },
      {
        "text_en": "Codewords should be a subset of all possible 2^n binary tuples to make error detection/correction possible.",
        "explanation_ar": "**الكلمات الصالحة مجموعة فرعية:** من أصل 2ⁿ تسلسل، نختار عددًا أقل لتكون صالحة، والباقي غير صالح → لتمييز الأخطاء."
      },
      {
        "text_en": "Example: BCD Codewords",
        "explanation_ar": "**مثال BCD:**\\n- `1001` → Codeword (9)\\n- `1010` → غير Codeword (غير صالح)"
      },
      {
        "text_en": "Error detection using Codewords",
        "explanation_ar": "**كشف الخطأ:**\\n- `0101` (5) → `0111` (7) → كلاهما Codeword → **غير مكتشف**\\n- `0101` → `0100` → غير Codeword → **مكتشف**"
      },
      {
        "text_en": "Why this detects permanent faults",
        "explanation_ar": "**لماذا يكشف الأعطال الدائمة؟** العطل في الدائرة قد يُخرج كلمة خارج المجموعة الصالحة → يُكتشف كخطأ."
      },
      {
        "text_en": "Difference from Time Redundancy (Slide 24)",
        "explanation_ar": "**الفرق عن التكرار الزمني:**\\n| الطريقة | الأساس | يكشف خطأين؟ | التكلفة |\n|---------|--------|-------------|--------|\n| زمني | مقارنة تنفيذين | نعم | تأخير |\n| كود | صحة الكلمة | يعتمد على d_min | حجم أكبر |"
      },
      {
        "text_en": "Important technical notes",
        "explanation_ar": "**ملاحظات تقنية مهمة:**\\n- الكلمات الصالحة دائمًا **أقل** من 2ⁿ.\\n- كلما قلّت الكلمات → زادت **المسافة بينها** → أقوى كشف.\\n- مثال: هامينغ (7,4) → 16 من 128.\\n- BCD → 10 من 16."
      },
      {
        "text_en": "--------------------------",
        "explanation_ar": "----- شرح إضافي -----"
      },
      {
        "text_en": "Why subset of 2^n?",
        "explanation_ar": "**لماذا مجموعة فرعية؟** لأن استخدام كل التسلسلات يجعل أي تغيير صالحًا → لا كشف للأخطاء."
      },
      {
        "text_en": "Visual example: n=3 even parity",
        "explanation_ar": "**مثال بصري (n=3، تكافؤ زوجي):**\\n- صالح: `000`, `011`, `101`, `110`\\n- غير صالح: `001`, `010`, `100`, `111`"
      },
      {
        "text_en": "Comparison with Hamming Code",
        "explanation_ar": "**مقارنة مع هامينغ:**\\n| الكود | الكلمات الصالحة | d_min |\n|------|------------------|------|\n| BCD | 10 من 16 | 1 |\n| هامينغ | 16 من 128 | 3 |"
      }
    ],
    "questions_en_ar": {
      "a_current_slide_qa": [
        {
          "type": "Multiple Choice",
          "question_en": "What is a 'code word'?",
          "options": [
            "(a) Any binary sequence",
            "(b) A valid representation of data according to the code",
            "(c) A sequence with errors",
            "(d) A parity bit"
          ],
          "answer_en": "(b) A valid representation of data according to the code",
          "explanation_ar": "كلمة الكود هي التي تتبع قواعد الكود وتُمثّل بيانات صحيحة."
        },
        {
          "type": "Multiple Choice",
          "question_en": "In BCD, is `1010` a codeword?",
          "options": [
            "(a) Yes",
            "(b) No",
            "(c) Only if parity is even",
            "(d) Only for digit 10"
          ],
          "answer_en": "(b) No",
          "explanation_ar": "`1010` لا يُمثّل أي رقم من 0–9 → غير صالح."
        },
        {
          "type": "Multiple Choice",
          "question_en": "Why must codewords be a subset of all 2^n tuples?",
          "options": [
            "(a) To save memory",
            "(b) To enable error detection",
            "(c) To increase speed",
            "(d) To encrypt data"
          ],
          "answer_en": "(b) To enable error detection",
          "explanation_ar": "إذا كانت كل التسلسلات صالحة → لا نكتشف أي خطأ."
        },
        {
          "type": "True/False",
          "question_en": "A smaller set of codewords improves error detection.",
          "options": [
            "True",
            "False"
          ],
          "answer_en": "True",
          "explanation_ar": "كلما قلّت الكلمات الصالحة → زادت المسافة بينها → أسهل كشف الخطأ."
        },
        {
          "type": "Definition",
          "question_en": "Explain the difference between 'code word' and 'word'.",
          "answer_en": "A code word satisfies the code rules and represents valid data. A word is any n-tuple, even if invalid.",
          "explanation_ar": "كلمة الكود: صالحة وتُمثّل بيانات. Word: أي تسلسل، قد يكون غير صالح."
        }
      ],
      "b_previous_slides": [
        {
          "question_ar": "كيف تُطبّق فكرة **كلمة الكود** على **كود BCD** في الشريحة 32؟",
          "hint_ar": "في BCD: `0000` إلى `1001` هي **كلمات كود**، و`1010` إلى `1111` هي **غير كلمات كود**."
        },
        {
          "question_ar": "هل يمكن أن يكون لدينا كود بكل 2ⁿ كلمة صالحة؟",
          "hint_ar": "لا، لأنه لن يكون هناك تمييز بين الصحيح والخاطئ → لا كشف للأخطاء."
        }
      ]
    }
  }
]